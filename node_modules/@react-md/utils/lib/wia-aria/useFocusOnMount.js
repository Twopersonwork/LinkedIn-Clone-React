"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFocusOnMount = void 0;
var react_1 = require("react");
var focusElementWithin_1 = require("./focusElementWithin");
var getInstance_1 = require("./getInstance");
/**
 * This hook is used to focus an element once a component has mounted. To help
 * with keyboard click events, it will actually wait for an animation frame
 * before attempting to focus as an enter key might click both elements at the
 * same time.
 *
 * This hook will first focus the HTMLElement (if it is focusable) and then
 * focus an element based on the defaultFocus prop.
 *
 * @param refOrInstance - This is either a ref object containing the element to
 * focus or the element itself.
 * @param defaultFocus - The element to focus within the containing element once
 * it has been mounted. This can either be "first" or "last" to focus the first
 * or last focusable elements or a query selector string to find an element to
 * focus.
 * @param preventScroll - Boolean if the focus events should try to prevent the
 * default scroll-into-view behavior. This is generally recommended to be kept
 * as `false`, but can be useful to enable if the component mounts offscreen
 * during a transition.
 * @param programatic - Boolean if programatically focusable elements should be
 * included instead of only tab focusable.
 * @param disabled - Boolean if the focus behavior should be disabled.
 */
function useFocusOnMount(refOrInstance, defaultFocus, preventScroll, programatic, disabled) {
    if (preventScroll === void 0) { preventScroll = false; }
    if (programatic === void 0) { programatic = false; }
    if (disabled === void 0) { disabled = false; }
    react_1.useEffect(function () {
        if (disabled) {
            return;
        }
        var frame = window.requestAnimationFrame(function () {
            var instance = getInstance_1.getInstance(refOrInstance);
            if (!instance) {
                return;
            }
            instance.focus({ preventScroll: preventScroll });
            focusElementWithin_1.focusElementWithin(instance, defaultFocus, programatic, preventScroll);
        });
        return function () {
            window.cancelAnimationFrame(frame);
        };
    }, [defaultFocus, disabled, refOrInstance, programatic, preventScroll]);
}
exports.useFocusOnMount = useFocusOnMount;
//# sourceMappingURL=useFocusOnMount.js.map