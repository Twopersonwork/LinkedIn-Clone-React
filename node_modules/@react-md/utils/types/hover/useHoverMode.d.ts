import { Dispatch, MouseEventHandler, SetStateAction } from "react";
import { HoverModeActions } from "./useHoverModeContext";
/**
 * An object of event handlers that should be provided to a component to enable
 * and disable the visibility of a temporary element while hovering over that
 * component.
 *
 * @remarks \@since 2.8.0
 */
export interface HoverModeEventHandlers<E extends HTMLElement> {
    /**
     * An optional event handler to merge with the hover mode visibility hander.
     * If this function calls `event.stopPropagation()`, the hover mode behavior
     * will be disabled.
     */
    onClick?: MouseEventHandler<E>;
    /**
     * An optional event handler to merge with the hover mode visibility hander.
     * If this function calls `event.stopPropagation()`, the hover mode behavior
     * will be disabled.
     */
    onMouseEnter?: MouseEventHandler<E>;
    /**
     * An optional event handler to merge with the hover mode visibility hander.
     * If this function calls `event.stopPropagation()`, the hover mode behavior
     * will be disabled.
     */
    onMouseLeave?: MouseEventHandler<E>;
}
/** @remarks \@since 2.8.0 */
export interface HoverModeOnlyOptions<E extends HTMLElement> extends HoverModeEventHandlers<E> {
    /**
     * Boolean if the hover mode functionality should be disabled.
     *
     * @defaultValue `false`
     */
    disabled?: boolean;
    /**
     * Boolean if the element should start visible.
     *
     * @defaultValue `false`
     */
    defaultVisible?: boolean;
    /**
     * The amount of time to wait once the mouse has left the element before
     * setting the visibility to `false`.
     *
     * This will default to `0` if the `sticky` option is omitted or `false`.
     *
     * @defaultValue `0` or {@link DEFAULT_HOVER_MODE_STICKY_EXIT_TIME}
     */
    exitVisibilityDelay?: number;
}
/** @remarks \@since 2.8.0 */
export interface HoverModeOptions<E extends HTMLElement> extends HoverModeOnlyOptions<E>, HoverModeEventHandlers<E> {
    /**
     * Boolean if the hover mode should also provide a "sticky" mode which allows
     * the exit behavior to be disabled if the element is clicked.
     */
    sticky?: boolean;
}
/** @remarks \@since 2.8.0 */
export interface HoverModeOnlyReturnValue<E extends HTMLElement> extends HoverModeActions {
    /**
     * Boolean if the hover mode is currently working.
     */
    active: boolean;
    /**
     * Boolean if the temporary element should be visible.
     */
    visible: boolean;
    /** {@inheritDoc HoverModeEventHandlers} */
    handlers: Required<HoverModeEventHandlers<E>>;
    /**
     * A function to manually set the visibility state if you need even more
     * custom behavior.
     */
    setVisible: Dispatch<SetStateAction<boolean>>;
}
/** @remarks \@since 2.8.0 */
export interface HoverModeReturnValue<E extends HTMLElement> extends HoverModeOnlyReturnValue<E> {
    /**
     * Boolean if the the `visible` state is `true` because the user clicked an
     * element with the `stickyHandlers`.
     */
    stuck?: boolean;
    /** {@inheritDoc StickyHoverModeEventHandlers} */
    stickyHandlers?: Required<HoverModeEventHandlers<E>>;
}
/**
 * This hook is used to add the hover mode functionality to any component.
 *
 * @example
 * Displaying a Color Preview when hovering a Hex Code
 * ```tsx
 * interface Props {
 *   value: string;
 * }
 *
 * export default function Color({ value }: Props): ReactElement {
 *   const { visible, handlers } = useHoverMode();
 *
 *   return (
 *     <>
 *       <span
 *         {...handlers}
 *         style={{
 *           // pretend styles
 *         }}
 *       >
 *         {value}
 *       </span>
 *       <CSSTransition
 *         in={visible}
 *         classNames="opacity-change"
 *         timeout={150}
 *         mountOnEnter
 *         unmountOnExit
 *       >
 *         <span
 *           style={{
 *             backgroundColor: value,
 *             // other styles
 *           }}
 *         />
 *      </CSSTransition>
 *     </>
 *   );
 * }
 * ```
 *
 * @example
 * Sticky Usage with a Fixed Dialog
 * ```tsx
 * const {
 *   stuck,
 *   active,
 *   visible,
 *   setVisible,
 *   handlers,
 *   stickyHandlers,
 * } = useHoverMode({ sticky: true });
 * const buttonRef = useRef<HTMLButtonElement>(null);
 *
 * return (
 *   <>
 *     <Button ref={buttonRef} {...stickyHandlers}>
 *       Click Me
 *     </Button>
 *     <FixedDialog
 *       {...handlers}
 *       aria-labelledby="dialog-title-id"
 *       id="dialog-id"
 *       visible={visible}
 *       onRequestClose={() => setVisible(false)}
 *       fixedTo={buttonRef}
 *       anchor={BELOW_CENTER_ANCHOR}
 *       options={{ preventOverlap: true }}
 *       // this allows the close on outside click"" behavior" to work
 *       overlay={!stuck && active ? false : undefined}
 *       disableScrollLock={active}
 *     >
 *       <YourDialogContent />
 *    </FixedDialog>
 *   </>
 * );
 * ```
 *
 * @remarks \@since 2.8.0
 * @param options - An optional object of options to use. See
 * {@link HoverModeOnlyOptions} and {@link HoverModeOptions} for more details.
 * @returns either the {@link HoverModeReturnValue} or {@link HoverModeReturnValue}
 */
export declare function useHoverMode<E extends HTMLElement>(options?: HoverModeOnlyOptions<E>): HoverModeOnlyReturnValue<E>;
export declare function useHoverMode<E extends HTMLElement>(options: HoverModeOptions<E> & {
    sticky?: false;
}): HoverModeOnlyReturnValue<E>;
export declare function useHoverMode<E extends HTMLElement>(options: HoverModeOptions<E> & {
    sticky: true;
}): HoverModeReturnValue<E> & {
    stuck: boolean;
    stickyHandlers: Required<HoverModeEventHandlers<E>>;
};
