import { FixedPosition, FixedPositionOptions } from "./types";
/**
 * One of the most complicated functions in this project that will attempt to
 * position an element relative to another container element while still being
 * visible within the viewport. Below is the logical flow for attempting to fix
 * the element to the container:
 *
 * No Container: If there is no container element, return the provided x and y
 * positions and no styles since there's nothing we can use to calculate the
 * position.
 *
 * No Element: If the container was provided but the element to position does
 * not exist, return an style object containing the `left` and `top` values for
 * the container and apply as many of the positioning options as possible so
 * that the styles are "as close as possible" before the fixed element is added
 * to the DOM. This will also return the provided x and y positions since
 * nothing could be swapped around yet.
 *
 * Container and Element: If both the container and fixed element were provided,
 * apply all the positioning options to the `left` and `top` values of the
 * container based on the sizes of both elements.
 *
 * Now that the `left` and `top` values were applied, check to see if the
 * element is fully visible within the viewport with the provided positioning
 * options. If it is fully visible, do nothing else. If it isn't... follow the
 * next flow:
 *
 * First, check the horizontal sizes and make sure that the element is still
 * within the viewport with the provided viewwidth margin. If it isn't, first
 * try to swap only to a `right` style instead of left to see if that fixes it,
 * otherwise keep both the `left` and `right` styles.
 */
export declare function getFixedPosition({ container, element, anchor: propAnchor, initialX, initialY, vwMargin, vhMargin, xMargin, yMargin, width: widthType, preventOverlap, transformOrigin, disableSwapping, disableVHBounds, }: FixedPositionOptions): FixedPosition;
