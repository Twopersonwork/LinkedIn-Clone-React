var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
import { useCallback, useMemo } from "react";
import { loop } from "../../loop";
import { useKeyboardSearch, } from "../../search/useKeyboardSearch";
import { DEFAULT_GET_ITEM_VALUE, DEFAULT_VALUE_KEY } from "../../search/utils";
import { getKeyboardConfig, getStringifiedKeyConfig, transformKeys, } from "./utils";
/**
 * This is a low-level hook for providing custom keyboard movement based on key
 * configurations.  This normally shouldn't really be used externally since
 * you'll most likely want to use the "presets" of `useFocusMovement` and
 * `useActiveDescendantMovement` that implement the main movement types already
 * for you.
 *
 * The way this works is that it will general a list of mutable item refs that
 * should be applied to each DOM node for the corresponding `item` within the
 * `items` list. This list will change and regenerate itself each time the
 * `items` array changes so it'll always be in-sync with the DOM nodes. This
 * means that if you have some items that **should not be rendered**, they
 * should not be included within the items list. The main reason these item refs
 * are required is so that the `aria-acativedescendant` movement can scroll the
 * new "focused" element into view if needed while the "true" focus movement can
 * trigger a `ref.current.focus()` on the new item as needed.
 *
 * Finally, this will create a keydown event handler that will merge in the
 * optionally provided `onKeyDown` prop and check if the pressed key should
 * trigger a custom keyboard movement event.  If it does, an `onChange` event
 * will be fired with the matching data and allows for custom movement with
 * `target.focus()` or updating the `aria-activedescendant` attribute as needed.
 *
 * @typeParam D - The type of each data item within the items list.
 * @typeParam CE - The HTMLElement type of the container element that handles
 * the custom keyboard movement.
 * @typeParam IE - The HTMLElement type of each item within the container
 * element that can be focusable.
 */
export function useKeyboardMovement(_a) {
    var onKeyDown = _a.onKeyDown, incrementKeys = _a.incrementKeys, decrementKeys = _a.decrementKeys, jumpToFirstKeys = _a.jumpToFirstKeys, jumpToLastKeys = _a.jumpToLastKeys, _b = _a.stopPropagation, stopPropagation = _b === void 0 ? true : _b, onChange = _a.onChange, items = _a.items, resetTime = _a.resetTime, findMatchIndex = _a.findMatchIndex, focusedIndex = _a.focusedIndex, _c = _a.loopable, loopable = _c === void 0 ? true : _c, _d = _a.searchable, searchable = _d === void 0 ? true : _d, _e = _a.valueKey, valueKey = _e === void 0 ? DEFAULT_VALUE_KEY : _e, _f = _a.getItemValue, getItemValue = _f === void 0 ? DEFAULT_GET_ITEM_VALUE : _f;
    var keys = useMemo(function () { return __spreadArray(__spreadArray(__spreadArray(__spreadArray([], transformKeys(incrementKeys, "increment")), transformKeys(decrementKeys, "decrement")), transformKeys(jumpToFirstKeys, "first")), transformKeys(jumpToLastKeys, "last")); }, [incrementKeys, decrementKeys, jumpToFirstKeys, jumpToLastKeys]);
    var itemRefs = useMemo(function () { return Array.from(items, function () { return ({ current: null }); }); }, [items]);
    var handleSearch = useKeyboardSearch({
        items: items,
        valueKey: valueKey,
        getItemValue: getItemValue,
        onChange: function (data) {
            onChange(data, itemRefs);
        },
        searchIndex: focusedIndex,
        resetTime: resetTime,
        findMatchIndex: findMatchIndex,
    });
    var handleKeyDown = useCallback(function (event) {
        if (searchable) {
            handleSearch(event);
        }
        if (onKeyDown) {
            onKeyDown(event);
        }
        var target = event.target;
        var keyConfig = getKeyboardConfig(event, keys);
        if (!keyConfig || !target) {
            return;
        }
        // implementing custom behavior, so prevent default of scrolling or other
        // things
        event.preventDefault();
        if (stopPropagation) {
            event.stopPropagation();
        }
        var type = keyConfig.type;
        var lastIndex = items.length - 1;
        var index;
        switch (type) {
            case "first":
                index = 0;
                break;
            case "last":
                index = lastIndex;
                break;
            default:
                index = loop({
                    value: focusedIndex,
                    max: lastIndex,
                    increment: type === "increment",
                    minmax: !loopable,
                });
        }
        if (index === focusedIndex) {
            return;
        }
        var data = {
            index: index,
            item: items[index],
            items: items,
            query: getStringifiedKeyConfig(keyConfig),
            target: event.currentTarget,
        };
        onChange(data, itemRefs);
    }, [
        onKeyDown,
        stopPropagation,
        focusedIndex,
        keys,
        items,
        handleSearch,
        loopable,
        searchable,
        onChange,
        itemRefs,
    ]);
    return [itemRefs, handleKeyDown];
}
//# sourceMappingURL=useKeyboardMovement.js.map