var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { useEffect, useState } from "react";
import { useKeyboardMovement, } from "./useKeyboardMovement";
/**
 * This hook allows for custom keyboard focus movement using DOM focus behavior
 * by actually focusing each DOM node.
 *
 * To use this hook, you'll want to update the container element of all the
 * items to have a correct `role` applied as well as the `onKeyDown` event
 * handler provided by this hook. Then, you'll want to applied a
 * `ref={itemRefs[i]}` for each item within the items list so that the DOM nodes
 * can be focused as needed. Unfortunately, this means that all the child items
 * **must** either be an HTMLElement or the ref is forwarded down to the
 * HTMLElement.
 *
 * @typeParam D - The type of each data item within the items list.
 * @typeParam CE - The HTMLElement type of the container element that handles
 * the custom keyboard movement.
 * @typeParam IE - The HTMLElement type of each item within the container
 * element that can be focusable.
 */
export function useFocusMovement(_a) {
    var _b = _a.defaultFocusedIndex, defaultFocusedIndex = _b === void 0 ? -1 : _b, onChange = _a.onChange, options = __rest(_a, ["defaultFocusedIndex", "onChange"]);
    var _c = useState(defaultFocusedIndex), focusedIndex = _c[0], setFocusedIndex = _c[1];
    var _d = useKeyboardMovement(__assign(__assign({}, options), { focusedIndex: focusedIndex,
        onChange: function (data, itemRefs) {
            if (onChange) {
                onChange(data, itemRefs);
            }
            var index = data.index;
            if (index === -1) {
                return;
            }
            var item = itemRefs[index] && itemRefs[index].current;
            if (item) {
                item.focus();
            }
            setFocusedIndex(index);
        } })), itemRefs = _d[0], handleKeyDown = _d[1];
    useEffect(function () {
        if (defaultFocusedIndex === -1) {
            return;
        }
        var item = itemRefs[defaultFocusedIndex] && itemRefs[defaultFocusedIndex].current;
        if (item) {
            item.focus();
        }
        // only want to trigger on mount
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    return [itemRefs, handleKeyDown];
}
//# sourceMappingURL=useFocusMovement.js.map