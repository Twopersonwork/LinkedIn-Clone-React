import { createHorizontalPosition } from "./createHorizontalPosition";
import { createVerticalPosition } from "./createVerticalPosition";
import { findSizingContainer } from "./findSizingContainer";
import { getElementRect } from "./getElementRect";
import { getTransformOrigin } from "./getTransformOrigin";
import { getViewportSize } from "./getViewportSize";
/**
 * One of the most complicated functions in this project that will attempt to
 * position an element relative to another container element while still being
 * visible within the viewport. Below is the logical flow for attempting to fix
 * the element to the container:
 *
 * No Container: If there is no container element, return the provided x and y
 * positions and no styles since there's nothing we can use to calculate the
 * position.
 *
 * No Element: If the container was provided but the element to position does
 * not exist, return an style object containing the `left` and `top` values for
 * the container and apply as many of the positioning options as possible so
 * that the styles are "as close as possible" before the fixed element is added
 * to the DOM. This will also return the provided x and y positions since
 * nothing could be swapped around yet.
 *
 * Container and Element: If both the container and fixed element were provided,
 * apply all the positioning options to the `left` and `top` values of the
 * container based on the sizes of both elements.
 *
 * Now that the `left` and `top` values were applied, check to see if the
 * element is fully visible within the viewport with the provided positioning
 * options. If it is fully visible, do nothing else. If it isn't... follow the
 * next flow:
 *
 * First, check the horizontal sizes and make sure that the element is still
 * within the viewport with the provided viewwidth margin. If it isn't, first
 * try to swap only to a `right` style instead of left to see if that fixes it,
 * otherwise keep both the `left` and `right` styles.
 */
export function getFixedPosition(_a) {
    var container = _a.container, element = _a.element, _b = _a.anchor, propAnchor = _b === void 0 ? {} : _b, initialX = _a.initialX, initialY = _a.initialY, _c = _a.vwMargin, vwMargin = _c === void 0 ? 16 : _c, _d = _a.vhMargin, vhMargin = _d === void 0 ? 16 : _d, _e = _a.xMargin, xMargin = _e === void 0 ? 0 : _e, _f = _a.yMargin, yMargin = _f === void 0 ? 0 : _f, _g = _a.width, widthType = _g === void 0 ? "auto" : _g, _h = _a.preventOverlap, preventOverlap = _h === void 0 ? false : _h, _j = _a.transformOrigin, transformOrigin = _j === void 0 ? false : _j, _k = _a.disableSwapping, disableSwapping = _k === void 0 ? false : _k, _l = _a.disableVHBounds, disableVHBounds = _l === void 0 ? false : _l;
    container = findSizingContainer(container);
    var anchor = {
        x: propAnchor.x || "center",
        y: propAnchor.y || "below",
    };
    if (process.env.NODE_ENV !== "production") {
        if (widthType !== "auto" && anchor.x !== "center") {
            throw new Error('Unable to use a calculated width when the horizontal anchor is not `"center"`.');
        }
        if (preventOverlap && anchor.y !== "above" && anchor.y !== "below") {
            throw new Error('Unable to prevent overlap when the vertical anchor is not `"above"` or `"below"`');
        }
    }
    if (!container || !element) {
        return {
            actualX: anchor.x,
            actualY: anchor.y,
        };
    }
    var containerRect = container.getBoundingClientRect();
    var vh = getViewportSize("height");
    var vw = getViewportSize("width");
    var _m = getElementRect(element), height = _m.height, elWidth = _m.width;
    if (disableVHBounds) {
        var dialog = element.closest("[role='dialog']");
        if (!dialog) {
            initialY = (initialY !== null && initialY !== void 0 ? initialY : 0) + window.scrollY;
        }
    }
    var _o = createHorizontalPosition({
        x: anchor.x,
        vw: vw,
        vwMargin: vwMargin,
        xMargin: xMargin,
        width: widthType,
        elWidth: elWidth,
        initialX: initialX,
        containerRect: containerRect,
        disableSwapping: disableSwapping,
    }), left = _o.left, right = _o.right, width = _o.width, minWidth = _o.minWidth, actualX = _o.actualX;
    var _p = createVerticalPosition({
        y: anchor.y,
        vh: vh,
        vhMargin: vhMargin,
        yMargin: yMargin,
        initialY: initialY,
        elHeight: height,
        containerRect: containerRect,
        disableSwapping: disableSwapping,
        preventOverlap: preventOverlap,
        disableVHBounds: disableVHBounds,
    }), top = _p.top, bottom = _p.bottom, actualY = _p.actualY;
    return {
        actualX: actualX,
        actualY: actualY,
        style: {
            left: left,
            top: top,
            right: right,
            bottom: bottom,
            width: width,
            minWidth: minWidth,
            position: disableVHBounds ? "absolute" : "fixed",
            transformOrigin: transformOrigin
                ? getTransformOrigin({ x: actualX, y: actualY })
                : undefined,
        },
    };
}
//# sourceMappingURL=getFixedPosition.js.map