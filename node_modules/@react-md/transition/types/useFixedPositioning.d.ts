import { CSSProperties, RefObject } from "react";
import { TransitionProps } from "react-transition-group/Transition";
import { FixedPositionOptions, PositionAnchor } from "@react-md/utils";
export declare type FixedToFunction = () => HTMLElement | null;
/**
 * @remarks \@since 2.8.0 Supports `RefObject` implementation.
 */
export declare type FixedTo = RefObject<HTMLElement | null> | FixedToFunction | HTMLElement | string | null;
export declare type OptionalFixedPositionOptions = Omit<FixedPositionOptions, "container" | "element">;
export declare type GetFixedPositionOptions = (node: HTMLElement) => OptionalFixedPositionOptions;
export declare type PositionChange = (wanted: PositionAnchor, actual: PositionAnchor) => void;
export interface ScrollData {
    element: HTMLElement | null;
    fixedTo: HTMLElement | null;
    /**
     * Boolean if the `fixedTo` element is visible within the viewport. This is useful
     * if you'd like to hide the element only once the user scrolls these elements
     * out of view.
     */
    visible: boolean;
}
export declare type OnFixedPositionScroll = (event: Event, data: ScrollData) => void;
export declare type TransitionHooks = Pick<TransitionProps, "onEnter" | "onEntering" | "onEntered" | "onExited">;
export interface FixedPositioningOptions extends OptionalFixedPositionOptions, TransitionHooks {
    /**
     * The element that the transitioning node should be fixed to.
     */
    fixedTo: FixedTo;
    /**
     * An optional style object to merge and override the generated fixed
     * positioning styles.
     *
     * @example
     * Overriding
     * ```ts
     * useFixedPositioning({
     *   // this will force the `top` to always be `0`
     *   style: { top: 0 },
     * });
     * ```
     *
     * @remarks \@since 2.8.0
     */
    style?: CSSProperties;
    /**
     * An optional function to call to dynamically get the options when the node
     * has been added to the DOM. This is helpful if you need to check sizes or other
     * things once the DOM node has been added for initial positioning or other things
     * like that. The returned options will override the existing options
     */
    getOptions?: GetFixedPositionOptions;
    /**
     * An optional function to call when the element is in the DOM and a window resize
     * event has occurred. The main use-case for this is hiding the fixed element when
     * the page is resized.
     */
    onResize?(event: Event): void;
    /**
     * An optional function to call when the element is in the DOM and a window scroll
     * event has occurred. The main use-case for this is hiding the fixed element when
     * the element or the entire page has a scroll event.
     */
    onScroll?: OnFixedPositionScroll;
    /**
     * An optional function to call when the provide `xPosition` and `yPosition` are not
     * the same as the "calculated" position after trying to make the element fixed
     * within the viewport.
     */
    onPositionChange?: PositionChange;
}
interface FixedPositioningHookReturnValue extends Required<TransitionHooks> {
    style: CSSProperties;
    updateStyle(): void;
}
/**
 * This hook is used to automatically handle fixed positioning when an element
 * is used alongside a `Transition` from `react-transition-group`. This will
 * provide merged `onEnter`, `onEntering`, `onEntered`, and `onExited` handlers
 * to pass down as well as the current style object to apply to the element.
 *
 * Until the element has been removed from the DOM and is visible, the position
 * will automatically update when the user scrolls or resizes the screen.
 *
 * @remarks
 *
 * It is recommended to start the exit animation when that happens though.
 */
export declare function useFixedPositioning({ style: propStyle, onEnter, onEntering, onEntered, onExited, fixedTo, getOptions, onResize, onScroll, anchor: currentAnchor, initialX, initialY, xMargin, vwMargin, yMargin, vhMargin, width, onPositionChange, transformOrigin, preventOverlap, disableSwapping, disableVHBounds, }: FixedPositioningOptions): FixedPositioningHookReturnValue;
export {};
