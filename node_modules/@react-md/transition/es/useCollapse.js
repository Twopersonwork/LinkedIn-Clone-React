import { useMemo, useState } from "react";
import cn from "classnames";
import { COLLAPSE_TIMEOUT, DEFAULT_COLLAPSE_MIN_HEIGHT, DEFAULT_COLLAPSE_MIN_PADDING_BOTTOM, DEFAULT_COLLAPSE_MIN_PADDING_TOP, ENTER, ENTERING, EXIT, EXITED, EXITING, } from "./constants";
import { getElementSizing } from "./getElementSizing";
import { getTimeout } from "./getTimeout";
import { useTransition } from "./useTransition";
/**
 * The `useCollapse` hook is used to transition a child element in and
 * out of view by animating it's `max-height`. This means that the child
 * must either be an HTMLElement or a component that forwards the `ref`
 * to an HTMLElement and applies the `style`, `className`, and `hidden`
 * props to an HTMLElement.
 *
 * Simple Example:
 *
 * ```tsx
 * const Example = () => {
 *   const [collapsed, setCollapsed] = useState(true);
 *   const [rendered, transitionProps] = useCollapse(collapsed);
 *
 *   return (
 *     <>
 *       <Button onClick={() => setCollapsed(!collapsed)}>Toggle</Button>
 *       {rendered && (
 *         <div {...transitionProps}>
 *          <Text>Stuff that should be animated</Text>
 *          <div>Whatever content...</div>
 *         </div>
 *       )}
 *     </>
 *   );
 * }
 * ```
 *
 * Note: This **should not be used for `position: absolute` or `position: fixed`
 * elements**. Instead, the `ScaleTransition` or just a simple `transform`
 * transition should be used instead. Animating `max-height`, `padding-top`, and
 * `padding-bottom` is much less performant than `transform` transition since it
 * forces the DOM to repaint during the
 *
 * @param collapsed - Boolean if the element is currently collapsed. Changing
 * this value will cause the animation to trigger.
 * @param options - All the additional options available for the collapse
 * transition.
 * @returns An ordered list containing a boolean if the collapse should be
 * rendered in the DOM followed by an object of props to pass to the collapsible
 * element to handle the transition.
 */
export function useCollapse(collapsed, _a) {
    var _b = _a === void 0 ? {} : _a, className = _b.className, _c = _b.appear, appear = _c === void 0 ? false : _c, _d = _b.timeout, timeout = _d === void 0 ? COLLAPSE_TIMEOUT : _d, onEnter = _b.onEnter, onEntering = _b.onEntering, onEntered = _b.onEntered, onExit = _b.onExit, onExiting = _b.onExiting, onExited = _b.onExited, _e = _b.minHeight, minHeight = _e === void 0 ? DEFAULT_COLLAPSE_MIN_HEIGHT : _e, _f = _b.minPaddingTop, minPaddingTop = _f === void 0 ? DEFAULT_COLLAPSE_MIN_PADDING_TOP : _f, _g = _b.minPaddingBottom, minPaddingBottom = _g === void 0 ? DEFAULT_COLLAPSE_MIN_PADDING_BOTTOM : _g, _h = _b.temporary, temporary = _h === void 0 ? minHeight === 0 &&
        minPaddingTop === 0 &&
        minPaddingBottom === 0 : _h;
    var _j = useState(function () {
        if (!collapsed) {
            return undefined;
        }
        return {
            maxHeight: minHeight,
            paddingTop: minPaddingTop,
            paddingBottom: minPaddingBottom,
        };
    }), style = _j[0], setStyle = _j[1];
    var _k = useTransition({
        appear: appear,
        repaint: true,
        timeout: timeout,
        temporary: temporary,
        transitionIn: !collapsed,
        onEnter: function (node, isAppearing) {
            if (onEnter) {
                onEnter(node, isAppearing);
            }
            setStyle({
                maxHeight: minHeight,
                paddingTop: minPaddingTop,
                paddingBottom: minPaddingBottom,
            });
        },
        onEntering: function (node, isAppearing) {
            if (onEntering) {
                onEntering(node, isAppearing);
            }
            var _a = getElementSizing(node), maxHeight = _a.maxHeight, paddingTop = _a.paddingTop, paddingBottom = _a.paddingBottom;
            var defaultedTimeout = getTimeout(timeout, isAppearing);
            var duration = isAppearing
                ? defaultedTimeout.appear
                : defaultedTimeout.enter;
            setStyle({
                maxHeight: maxHeight,
                paddingTop: paddingTop,
                paddingBottom: paddingBottom,
                transitionDuration: duration + "ms",
            });
        },
        onEntered: function (node, isAppearing) {
            if (onEntered) {
                onEntered(node, isAppearing);
            }
            setStyle(undefined);
        },
        onExit: function (node) {
            if (onExit) {
                onExit(node);
            }
            var _a = getElementSizing(node), maxHeight = _a.maxHeight, paddingTop = _a.paddingTop, paddingBottom = _a.paddingBottom;
            setStyle({
                maxHeight: maxHeight,
                paddingTop: paddingTop,
                paddingBottom: paddingBottom,
                transitionDuration: getTimeout(timeout, false).exit + "ms",
            });
        },
        onExiting: function (node) {
            if (onExiting) {
                onExiting(node);
            }
            setStyle({
                maxHeight: minHeight,
                paddingTop: minPaddingTop,
                paddingBottom: minPaddingBottom,
                transitionDuration: getTimeout(timeout, false).exit + "ms",
            });
        },
        onExited: function (node) {
            if (onExited) {
                onExited(node);
            }
            setStyle({
                maxHeight: minHeight,
                paddingTop: minPaddingTop,
                paddingBottom: minPaddingBottom,
            });
        },
    }), rendered = _k.rendered, stage = _k.stage, ref = _k.ref;
    var entering = stage === ENTER || stage === ENTERING;
    var exiting = stage === EXIT || stage === EXITING;
    var collapsable = useMemo(function () { return Object.values(getTimeout(timeout, false)).some(function (v) { return v !== 0; }); }, [timeout]);
    var hidden = collapsed &&
        rendered &&
        stage === EXITED &&
        !temporary &&
        minHeight === 0 &&
        minPaddingTop === 0 &&
        minPaddingBottom === 0;
    return [
        rendered,
        {
            ref: ref,
            hidden: hidden,
            style: style,
            className: cn({
                "rmd-collapse": collapsable,
                "rmd-collapse--enter": entering,
                "rmd-collapse--leave": exiting,
                "rmd-collapse--no-overflow": collapsed || style,
            }, className),
        },
    ];
}
//# sourceMappingURL=useCollapse.js.map