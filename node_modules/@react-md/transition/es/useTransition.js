var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { useEffect, useReducer, useRef } from "react";
import { useEnsuredRef } from "@react-md/utils";
import { ENTER, ENTERED, ENTERING, EXIT, EXITED, EXITING, UNMOUNT, } from "./constants";
import { getNextStage } from "./getNextStage";
import { getTimeout } from "./getTimeout";
import { getTimeoutDuration } from "./getTimeoutDuration";
/**
 *
 * @internal
 */
var reducer = function (state, action) {
    switch (action) {
        case ENTER:
        case ENTERING:
        case EXIT:
        case EXITING:
        case EXITED:
            return __assign(__assign({}, state), { rendered: true, stage: action });
        case ENTERED:
            return { rendered: true, stage: action, appearing: false };
        case UNMOUNT:
            return { stage: EXITED, rendered: false, appearing: false };
        default:
            return state;
    }
};
/**
 *
 * @internal
 */
var INITIAL_STATE = {
    appearing: false,
    rendered: true,
    stage: ENTERED,
};
/**
 *
 * @internal
 */
var getInitialState = function (transitionIn, temporary, appear) { return function () {
    return {
        rendered: !temporary || transitionIn,
        appearing: appear && transitionIn,
        stage: transitionIn && !appear ? ENTERED : EXITED,
    };
}; };
/**
 * This is heavily inspired by the `Transition` component from
 * `react-transition-group` since it's really just a hook version of it.
 *
 * This hook allows you to transition between an enter and exit state with
 * defined timeouts, but you'll most likely be looking for the
 * `useCSSTransition` instead.
 *
 * @param options - All the options used for the transition.
 * @returns An object describing the current transition stage and props that
 * should be passed to a component.
 */
export function useTransition(_a) {
    var _b = _a.appear, appear = _b === void 0 ? false : _b, _c = _a.repaint, repaint = _c === void 0 ? false : _c, _d = _a.temporary, temporary = _d === void 0 ? false : _d, transitionIn = _a.transitionIn, propTimeout = _a.timeout, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited, propRef = _a.ref;
    var _e = useReducer(reducer, INITIAL_STATE, getInitialState(transitionIn, temporary, appear)), _f = _e[0], stage = _f.stage, rendered = _f.rendered, appearing = _f.appearing, dispatch = _e[1];
    // need to store in mutable ref since these are mostly going to be arrow
    // functions and shouldn't cause the transitions to change
    var handlers = useRef({
        onEnter: onEnter,
        onEntering: onEntering,
        onEntered: onEntered,
        onExit: onExit,
        onExiting: onExiting,
        onExited: onExited,
    });
    useEffect(function () {
        handlers.current = {
            onEnter: onEnter,
            onEntering: onEntering,
            onEntered: onEntered,
            onExit: onExit,
            onExiting: onExiting,
            onExited: onExited,
        };
    });
    var timeout = getTimeout(propTimeout, appear);
    var _g = useEnsuredRef(propRef), nodeRef = _g[0], refHandler = _g[1];
    var disableEnterExitTransition = useRef(!appear || !transitionIn);
    // this effect handles the transition from:
    // - EXITED -> ENTER
    // - ENTERED -> EXIT
    // - EXITED -> ENTERED (when enter timeout is 0)
    // - ENTERED -> EXITED (when exit timeout is 0)
    //
    // all the dependencies are ignored except for `transitionIn` since the
    // other values changing would actually cause more bugs and this effect
    // really doesn't care if they changed.
    useEffect(function () {
        // should never trigger a transition on mount unless both the `appear` and
        // `transitionIn` are enabled for the appear transition
        if (disableEnterExitTransition.current) {
            disableEnterExitTransition.current = false;
            return;
        }
        var duration = 0;
        if (transitionIn) {
            duration = appearing ? timeout.appear : timeout.enter;
        }
        else {
            duration = timeout.exit;
        }
        if (duration > 0) {
            dispatch(transitionIn ? ENTER : EXIT);
        }
        else {
            dispatch(transitionIn ? ENTERED : EXITED);
        }
        // see comment above about why it's only `transitionIn`
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [transitionIn]);
    var isFirstRender = useRef(true);
    // this effect handles the transitions for:
    // - ENTER -> ENTERING
    // - ENTERING -> ENTERED
    // - EXIT -> EXITING
    // - EXITING -> EXIT
    useEffect(function () {
        // need to skip the effects on first render since it should only be called
        // after a transition change
        if (isFirstRender.current) {
            isFirstRender.current = false;
            return;
        }
        var node = nodeRef.current;
        if (node) {
            if (repaint && stage !== EXITED && stage !== ENTERED) {
                // force repaint for CSS transitions
                // eslint-disable-next-line no-unused-expressions
                node.scrollTop;
            }
            var _a = handlers.current, onEnter_1 = _a.onEnter, onEntering_1 = _a.onEntering, onEntered_1 = _a.onEntered, onExit_1 = _a.onExit, onExiting_1 = _a.onExiting, onExited_1 = _a.onExited;
            switch (stage) {
                case ENTER:
                    if (onEnter_1) {
                        onEnter_1(node, appearing);
                    }
                    break;
                case ENTERING:
                    if (onEntering_1) {
                        onEntering_1(node, appearing);
                    }
                    break;
                case ENTERED:
                    if (onEntered_1) {
                        onEntered_1(node, appearing);
                    }
                    break;
                case EXIT:
                    if (onExit_1) {
                        onExit_1(node);
                    }
                    break;
                case EXITING:
                    if (onExiting_1) {
                        onExiting_1(node);
                    }
                    break;
                case EXITED:
                    if (onExited_1) {
                        onExited_1(node);
                    }
                    break;
                // no default
            }
        }
        var nextStage = getNextStage(stage);
        if (stage === nextStage) {
            if (stage === EXITED && temporary) {
                dispatch(UNMOUNT);
            }
            return;
        }
        var duration = getTimeoutDuration(stage, timeout.appear, timeout.enter, timeout.exit, appearing);
        if (duration <= 0) {
            dispatch(nextStage);
            return;
        }
        var dispatchTimeout = window.setTimeout(function () {
            dispatch(nextStage);
        }, duration);
        return function () {
            window.clearTimeout(dispatchTimeout);
        };
    }, [
        nodeRef,
        appearing,
        repaint,
        stage,
        temporary,
        timeout.appear,
        timeout.enter,
        timeout.exit,
    ]);
    return {
        ref: refHandler,
        stage: stage,
        rendered: rendered,
        appearing: appearing,
        dispatch: dispatch,
    };
}
//# sourceMappingURL=useTransition.js.map