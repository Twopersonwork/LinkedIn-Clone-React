"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFixedPositioning = void 0;
var react_1 = require("react");
var utils_1 = require("@react-md/utils");
function getFixedTo(fixedTo) {
    if (!fixedTo) {
        return null;
    }
    if (typeof fixedTo === "string") {
        return (document.getElementById(fixedTo) ||
            document.querySelector(fixedTo));
    }
    if (typeof fixedTo === "function") {
        return fixedTo();
    }
    if ("current" in fixedTo) {
        return fixedTo.current;
    }
    return fixedTo;
}
/**
 * This hook is used to automatically handle fixed positioning when an element
 * is used alongside a `Transition` from `react-transition-group`. This will
 * provide merged `onEnter`, `onEntering`, `onEntered`, and `onExited` handlers
 * to pass down as well as the current style object to apply to the element.
 *
 * Until the element has been removed from the DOM and is visible, the position
 * will automatically update when the user scrolls or resizes the screen.
 *
 * @remarks
 *
 * It is recommended to start the exit animation when that happens though.
 */
function useFixedPositioning(_a) {
    var propStyle = _a.style, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExited = _a.onExited, fixedTo = _a.fixedTo, getOptions = _a.getOptions, onResize = _a.onResize, onScroll = _a.onScroll, _b = _a.anchor, currentAnchor = _b === void 0 ? {} : _b, initialX = _a.initialX, initialY = _a.initialY, _c = _a.xMargin, xMargin = _c === void 0 ? 0 : _c, _d = _a.vwMargin, vwMargin = _d === void 0 ? 16 : _d, _e = _a.yMargin, yMargin = _e === void 0 ? 0 : _e, _f = _a.vhMargin, vhMargin = _f === void 0 ? 16 : _f, _g = _a.width, width = _g === void 0 ? "auto" : _g, onPositionChange = _a.onPositionChange, _h = _a.transformOrigin, transformOrigin = _h === void 0 ? false : _h, _j = _a.preventOverlap, preventOverlap = _j === void 0 ? false : _j, _k = _a.disableSwapping, disableSwapping = _k === void 0 ? false : _k, _l = _a.disableVHBounds, disableVHBounds = _l === void 0 ? false : _l;
    var _m = react_1.useState(), style = _m[0], setStyle = _m[1];
    var _o = react_1.useState(null), element = _o[0], setElement = _o[1];
    var updateStyle = react_1.useCallback(function (nextElement) {
        var node = nextElement !== null && nextElement !== void 0 ? nextElement : element;
        if (typeof nextElement !== "undefined") {
            setElement(nextElement);
        }
        if (!node) {
            return;
        }
        var anchor = {
            x: currentAnchor.x || "center",
            y: currentAnchor.y || "below",
        };
        var overrides = typeof getOptions === "function" ? getOptions(node) : {};
        var opts = __assign({ initialX: initialX,
            initialY: initialY,
            xMargin: xMargin,
            vwMargin: vwMargin,
            yMargin: yMargin,
            vhMargin: vhMargin,
            width: width,
            transformOrigin: transformOrigin,
            preventOverlap: preventOverlap,
            disableSwapping: disableSwapping,
            disableVHBounds: disableVHBounds,
            anchor: anchor, container: getFixedTo(fixedTo), element: node }, overrides);
        var _a = utils_1.getFixedPosition(opts), style = _a.style, actualX = _a.actualX, actualY = _a.actualY;
        var actual = { x: actualX, y: actualY };
        if (onPositionChange &&
            (anchor.x !== actual.x || anchor.y !== actual.y)) {
            onPositionChange(anchor, actual);
        }
        setStyle(style);
    }, [
        currentAnchor.x,
        currentAnchor.y,
        disableSwapping,
        disableVHBounds,
        fixedTo,
        getOptions,
        initialX,
        initialY,
        onPositionChange,
        preventOverlap,
        transformOrigin,
        vhMargin,
        vwMargin,
        width,
        xMargin,
        yMargin,
        element,
    ]);
    var handleEnter = react_1.useCallback(function (node, appear) {
        if (onEnter) {
            onEnter(node, appear);
        }
        updateStyle(node);
    }, [onEnter, updateStyle]);
    var handleEntering = react_1.useCallback(function (node, appear) {
        if (onEntering) {
            onEntering(node, appear);
        }
        updateStyle(node);
    }, [onEntering, updateStyle]);
    var handleEntered = react_1.useCallback(function (node, appear) {
        if (onEntered) {
            onEntered(node, appear);
        }
        updateStyle(node);
    }, [onEntered, updateStyle]);
    var handleExited = react_1.useCallback(function (node) {
        if (onExited) {
            onExited(node);
        }
        setElement(null);
    }, [onExited]);
    utils_1.useResizeListener({
        enabled: !!element,
        onResize: function (event) {
            if (onResize) {
                onResize(event);
            }
            updateStyle();
        },
    });
    utils_1.useScrollListener({
        enabled: !!element,
        onScroll: function (event) {
            if (onScroll) {
                var container = getFixedTo(fixedTo);
                var containerRect = container && container.getBoundingClientRect();
                var elementRect = element && element.getBoundingClientRect();
                var visible = false;
                if (containerRect && elementRect) {
                    var vh = utils_1.getViewportSize("height");
                    var vw = utils_1.getViewportSize("width");
                    var top_1 = Math.min(elementRect.top, containerRect.top);
                    var right = Math.max(elementRect.right, containerRect.right);
                    var bottom = Math.max(elementRect.bottom, containerRect.bottom);
                    var left = Math.min(elementRect.left, containerRect.left);
                    visible = bottom >= 0 && top_1 <= vh && right >= 0 && left <= vw;
                }
                onScroll(event, {
                    element: element,
                    fixedTo: container,
                    visible: visible,
                });
            }
            updateStyle();
        },
    });
    react_1.useEffect(function () {
        updateStyle();
        // Need to only update when the initialX and initialY values are changed.
        // If this is triggered each time the updateStyle is changed, it causes an
        // infinite loop.
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [initialX, initialY]);
    return {
        style: __assign(__assign({}, style), propStyle),
        updateStyle: updateStyle,
        onEnter: handleEnter,
        onEntering: handleEntering,
        onEntered: handleEntered,
        onExited: handleExited,
    };
}
exports.useFixedPositioning = useFixedPositioning;
//# sourceMappingURL=useFixedPositioning.js.map