"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Collapse = void 0;
var react_1 = require("react");
var classnames_1 = __importDefault(require("classnames"));
var constants_1 = require("./constants");
var useCollapse_1 = require("./useCollapse");
/**
 * The `Collapse` component is used to transition a child element in and
 * out of view by animating it's `max-height`. This means that the child must
 * either be an HTMLElement or a component that forwards the `ref` to an
 * HTMLElement and applies the `style`, `className`, and `hidden` props to an
 * HTMLElement.
 *
 * Note: This component **should not be used for `position: absolute` or
 * `position: fixed` elements**. Instead, the `ScaleTransition` or just a simple
 * `transform` transition should be used instead. Animating `max-height`,
 * `padding-top`, and `padding-bottom` is much less performant than `transform`
 * transition since it forces DOM repaints.
 */
function Collapse(_a) {
    var children = _a.children, collapsed = _a.collapsed, className = _a.className, _b = _a.appear, appear = _b === void 0 ? false : _b, _c = _a.timeout, timeout = _c === void 0 ? constants_1.COLLAPSE_TIMEOUT : _c, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExit = _a.onExit, onExiting = _a.onExiting, onExited = _a.onExited, _d = _a.minHeight, minHeight = _d === void 0 ? constants_1.DEFAULT_COLLAPSE_MIN_HEIGHT : _d, _e = _a.minPaddingTop, minPaddingTop = _e === void 0 ? constants_1.DEFAULT_COLLAPSE_MIN_PADDING_TOP : _e, _f = _a.minPaddingBottom, minPaddingBottom = _f === void 0 ? constants_1.DEFAULT_COLLAPSE_MIN_PADDING_BOTTOM : _f, _g = _a.temporary, temporary = _g === void 0 ? minHeight === 0 && minPaddingTop === 0 && minPaddingBottom === 0 : _g;
    var _h = useCollapse_1.useCollapse(collapsed, {
        appear: appear,
        temporary: temporary,
        className: className,
        timeout: timeout,
        onEnter: onEnter,
        onEntering: onEntering,
        onEntered: onEntered,
        onExit: onExit,
        onExiting: onExiting,
        onExited: onExited,
        minHeight: minHeight,
        minPaddingBottom: minPaddingBottom,
        minPaddingTop: minPaddingTop,
    }), rendered = _h[0], transitionProps = _h[1];
    if (!rendered) {
        return null;
    }
    var child = react_1.Children.only(children);
    var transitionStyle = transitionProps.style;
    var childStyle = child.props.style;
    return react_1.cloneElement(child, __assign(__assign({}, transitionProps), { style: transitionStyle ? __assign(__assign({}, transitionStyle), childStyle) : childStyle, className: classnames_1.default(transitionProps.className, child.props.className) }));
}
exports.Collapse = Collapse;
/* istanbul ignore next */
if (process.env.NODE_ENV !== "production") {
    try {
        var PropTypes = require("prop-types");
        Collapse.propTypes = {
            style: PropTypes.object,
            className: PropTypes.string,
            collapsed: PropTypes.bool.isRequired,
            minHeight: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
            minPaddingTop: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
            minPaddingBottom: PropTypes.oneOfType([
                PropTypes.string,
                PropTypes.number,
            ]),
            timeout: PropTypes.oneOfType([
                PropTypes.number,
                PropTypes.shape({
                    appear: PropTypes.number,
                    enter: PropTypes.number,
                    exit: PropTypes.number,
                }),
            ]),
            temporary: PropTypes.bool,
            children: PropTypes.oneOfType([PropTypes.func, PropTypes.element])
                .isRequired,
            onEnter: PropTypes.func,
            onEntering: PropTypes.func,
            onEntered: PropTypes.func,
            onExit: PropTypes.func,
            onExiting: PropTypes.func,
            onExited: PropTypes.func,
        };
    }
    catch (e) { }
}
//# sourceMappingURL=Collapse.js.map