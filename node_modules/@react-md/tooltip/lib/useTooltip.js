"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTooltip = void 0;
var react_1 = require("react");
var classnames_1 = __importDefault(require("classnames"));
var transition_1 = require("@react-md/transition");
var utils_1 = require("@react-md/utils");
var constants_1 = require("./constants");
var useTooltipPosition_1 = require("./useTooltipPosition");
/** @internal */
function getAnchor(position) {
    switch (position) {
        case "above":
            return utils_1.ABOVE_CENTER_ANCHOR;
        case "below":
            return utils_1.BELOW_CENTER_ANCHOR;
        case "left":
            return utils_1.CENTER_LEFT_ANCHOR;
        case "right":
            return utils_1.CENTER_RIGHT_ANCHOR;
        default:
            throw new Error("Invalid position: " + position);
    }
}
/**
 * This hook is used to handle the positioning and visibility of the tooltip
 * component mostly within the {@link Tooltipped} component.
 *
 * @example
 * Simple Usage
 * ```tsx
 * import { Button } from "@react-md/button";
 * import { useTooltip, Tooltip } from "@react-md/tooltip";
 *
 * function Example() {
 *   const { tooltipProps, elementProps } = useTooltip({
 *     baseId: 'my-element',
 *   });
 *
 *   return (
 *     <>
 *       <Button {...elementProps}>Button</Button>
 *       <Tooltip {...tooltipProps}>
 *         Tooltip Content
 *       </Tooltip>
 *     </>
 *   );
 * }
 * ```
 *
 * @remarks \@since 2.8.0
 * @param options - All the {@link TooltipHookOptions} to configure the tooltip behavior.
 * @returns The {@link TooltipHookReturnValue}
 */
function useTooltip(_a) {
    var baseId = _a.baseId, style = _a.style, describedBy = _a.describedBy, _b = _a.dense, dense = _b === void 0 ? false : _b, _c = _a.spacing, spacing = _c === void 0 ? constants_1.DEFAULT_TOOLTIP_SPACING : _c, _d = _a.denseSpacing, denseSpacing = _d === void 0 ? constants_1.DEFAULT_TOOLTIP_DENSE_SPACING : _d, determinedPosition = _a.position, _e = _a.defaultPosition, defaultPosition = _e === void 0 ? constants_1.DEFAULT_TOOLTIP_POSITION : _e, _f = _a.vwMargin, vwMargin = _f === void 0 ? constants_1.DEFAULT_TOOLTIP_MARGIN : _f, _g = _a.vhMargin, vhMargin = _g === void 0 ? constants_1.DEFAULT_TOOLTIP_MARGIN : _g, _h = _a.threshold, threshold = _h === void 0 ? constants_1.DEFAULT_TOOLTIP_THRESHOLD : _h, _j = _a.touchTime, touchTime = _j === void 0 ? constants_1.DEFAULT_TOOLTIP_DELAY : _j, _k = _a.focusTime, focusTime = _k === void 0 ? constants_1.DEFAULT_TOOLTIP_DELAY : _k, propOnFocus = _a.onFocus, propOnBlur = _a.onBlur, propOnKeyDown = _a.onKeyDown, onClick = _a.onClick, onMouseEnter = _a.onMouseEnter, onMouseLeave = _a.onMouseLeave, propOnTouchStart = _a.onTouchStart, propOnContextMenu = _a.onContextMenu, onEnter = _a.onEnter, onEntering = _a.onEntering, onEntered = _a.onEntered, onExited = _a.onExited, disableSwapping = _a.disableSwapping, disabled = _a.disableHoverMode, _l = _a.disableAutoSpacing, disableAutoSpacing = _l === void 0 ? process.env.NODE_ENV === "test" : _l;
    var containerRef = react_1.useRef(null);
    var _m = useTooltipPosition_1.useTooltipPosition({
        position: determinedPosition,
        defaultPosition: defaultPosition,
        threshold: threshold,
    }), position = _m[0], updatePosition = _m[1];
    var mode = utils_1.useUserInteractionMode();
    var _o = react_1.useState(null), initiatedBy = _o[0], setInitiatedBy = _o[1];
    var windowFocusEvent = react_1.useRef(false);
    var timeout = react_1.useRef(undefined);
    var _p = utils_1.useHoverMode({
        disabled: disabled,
        onClick: function (event) {
            onClick === null || onClick === void 0 ? void 0 : onClick(event);
            if (event.isPropagationStopped()) {
                return;
            }
            setVisible(false);
            setInitiatedBy(null);
        },
        onMouseEnter: function (event) {
            onMouseEnter === null || onMouseEnter === void 0 ? void 0 : onMouseEnter(event);
            if (initiatedBy !== null) {
                event.stopPropagation();
                return;
            }
            containerRef.current = event.currentTarget;
            updatePosition(event.currentTarget);
            setInitiatedBy("mouse");
        },
        onMouseLeave: function (event) {
            onMouseLeave === null || onMouseLeave === void 0 ? void 0 : onMouseLeave(event);
            if (initiatedBy !== "mouse") {
                event.stopPropagation();
                return;
            }
            setInitiatedBy(null);
        },
    }), visible = _p.visible, setVisible = _p.setVisible, mouseHandlers = _p.handlers, disableHoverMode = _p.disableHoverMode, others = __rest(_p, ["visible", "setVisible", "handlers", "disableHoverMode"]);
    var hide = react_1.useCallback(function () {
        window.clearTimeout(timeout.current);
        setVisible(false);
        setInitiatedBy(null);
    }, [setVisible]);
    var onBlur = function (event) {
        propOnBlur === null || propOnBlur === void 0 ? void 0 : propOnBlur(event);
        if (initiatedBy !== "keyboard") {
            return;
        }
        hide();
    };
    var onFocus = function (event) {
        propOnFocus === null || propOnFocus === void 0 ? void 0 : propOnFocus(event);
        // if the element gained focus immediately after the browser window gains
        // focus, do not start timer and ignore this event instead
        if (windowFocusEvent.current) {
            windowFocusEvent.current = false;
            return;
        }
        if (mode !== "keyboard" || initiatedBy !== null) {
            return;
        }
        setInitiatedBy("keyboard");
        window.clearTimeout(timeout.current);
        containerRef.current = event.currentTarget;
        updatePosition(event.currentTarget);
        timeout.current = window.setTimeout(function () {
            setVisible(true);
        }, focusTime);
    };
    var onKeyDown = function (event) {
        propOnKeyDown === null || propOnKeyDown === void 0 ? void 0 : propOnKeyDown(event);
        if (initiatedBy !== "keyboard" || event.key !== "Escape") {
            return;
        }
        hide();
    };
    var onTouchStart = function (event) {
        propOnTouchStart === null || propOnTouchStart === void 0 ? void 0 : propOnTouchStart(event);
        if (event.isPropagationStopped() || mode !== "touch") {
            return;
        }
        setInitiatedBy("touch");
        window.clearTimeout(timeout.current);
        timeout.current = window.setTimeout(function () {
            setVisible(true);
        }, touchTime);
        containerRef.current = event.currentTarget;
        updatePosition(event.currentTarget);
    };
    var onContextMenu = function (event) {
        var _a;
        propOnContextMenu === null || propOnContextMenu === void 0 ? void 0 : propOnContextMenu(event);
        if (event.isPropagationStopped() || mode !== "touch") {
            return;
        }
        // Need to prevent the context menu from displaying and display the tooltip
        // instead.
        event.preventDefault();
        var selection = window.getSelection();
        var node = (_a = selection === null || selection === void 0 ? void 0 : selection.anchorNode) === null || _a === void 0 ? void 0 : _a.parentElement;
        /* istanbul ignore next */
        if (selection && node && event.currentTarget.contains(node)) {
            selection.empty();
        }
        setVisible(true);
    };
    react_1.useEffect(function () {
        if (mode !== "keyboard") {
            windowFocusEvent.current = false;
            return;
        }
        var handler = function () {
            if (document.hidden) {
                hide();
                windowFocusEvent.current =
                    document.activeElement === containerRef.current;
            }
        };
        window.addEventListener("visibilitychange", handler);
        return function () {
            window.removeEventListener("visibilitychange", handler);
        };
    }, [hide, mode]);
    react_1.useEffect(function () {
        if (initiatedBy !== "touch") {
            return;
        }
        window.addEventListener("touchmove", hide, true);
        window.addEventListener("touchend", hide, true);
        return function () {
            window.removeEventListener("touchmove", hide, true);
            window.removeEventListener("touchend", hide, true);
        };
    }, [hide, initiatedBy, setVisible]);
    utils_1.useOnUnmount(function () {
        window.clearTimeout(timeout.current);
    });
    var _q = transition_1.useFixedPositioning({
        style: style,
        anchor: getAnchor(position),
        disableSwapping: disableSwapping !== null && disableSwapping !== void 0 ? disableSwapping : !!determinedPosition,
        fixedTo: containerRef,
        getOptions: function (node) {
            var tooltipSpacing = dense ? denseSpacing : spacing;
            /* istanbul ignore next */
            if (!disableAutoSpacing) {
                tooltipSpacing = window
                    .getComputedStyle(node)
                    .getPropertyValue(constants_1.TOOLTIP_SPACING_VAR);
            }
            var currentSpacing = utils_1.unitToNumber(tooltipSpacing);
            return {
                vwMargin: vwMargin,
                vhMargin: vhMargin,
                xMargin: currentSpacing,
                yMargin: currentSpacing,
            };
        },
        onResize: hide,
        onScroll: hide,
        onEnter: onEnter,
        onEntering: onEntering,
        onEntered: onEntered,
        onExited: onExited,
    }), _u = _q.updateStyle, positionProps = __rest(_q, ["updateStyle"]);
    var tooltipHandlers = __assign(__assign({}, mouseHandlers), { onFocus: onFocus,
        onBlur: onBlur,
        onKeyDown: onKeyDown,
        onTouchStart: onTouchStart,
        onContextMenu: onContextMenu });
    var tooltipId = baseId + "-tooltip";
    var elementProps = __assign({ id: baseId, "aria-describedby": classnames_1.default(visible && tooltipId, describedBy) || undefined }, tooltipHandlers);
    var tooltipProps = __assign({ id: tooltipId, dense: dense,
        visible: visible,
        position: position }, positionProps);
    return __assign(__assign({}, others), { visible: visible,
        setVisible: setVisible, handlers: tooltipHandlers, elementProps: elementProps,
        tooltipProps: tooltipProps,
        disableHoverMode: disableHoverMode });
}
exports.useTooltip = useTooltip;
//# sourceMappingURL=useTooltip.js.map