"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTextField = void 0;
var react_1 = require("react");
var icon_1 = require("@react-md/icon");
var getErrorIcon_1 = require("./getErrorIcon");
var getErrorMessage_1 = require("./getErrorMessage");
var isErrored_1 = require("./isErrored");
var noop = function () {
    // do nothing
};
/**
 * This hook is used to control the `value` for a `TextField` or `TextArea`
 * component along with some simple validation checks using the browser validity
 * api/constraint validation. This also provides props that can be passed to the
 * `FormMessage` component to display error messages or help text.
 *
 * Note: Even though this hook exists, it is highly recommended to use a form
 * helper library like [react-hook-form](https://react-hook-form.com/) for more
 * complex forms
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
 * @param options - All the options used to control the functionality of this
 * hook.
 * @returns @see {@link TextFieldHookReturnType}
 * @remarks \@since 2.5.0
 */
function useTextField(_a) {
    var id = _a.id, _b = _a.defaultValue, defaultValue = _b === void 0 ? "" : _b, theme = _a.theme, pattern = _a.pattern, required = _a.required, minLength = _a.minLength, maxLength = _a.maxLength, _c = _a.disableMaxLength, disableMaxLength = _c === void 0 ? false : _c, onBlur = _a.onBlur, onChange = _a.onChange, helpText = _a.helpText, propErrorIcon = _a.errorIcon, _d = _a.counter, counter = _d === void 0 ? false : _d, _e = _a.disableMessage, disableMessage = _e === void 0 ? false : _e, _f = _a.validateOnChange, validateOnChange = _f === void 0 ? "recommended" : _f, _g = _a.isErrored, isErrored = _g === void 0 ? isErrored_1.defaultIsErrored : _g, _h = _a.onErrorChange, onErrorChange = _h === void 0 ? noop : _h, _j = _a.getErrorIcon, getErrorIcon = _j === void 0 ? getErrorIcon_1.defaultGetErrorIcon : _j, _k = _a.getErrorMessage, getErrorMessage = _k === void 0 ? getErrorMessage_1.defaultGetErrorMessage : _k;
    var _l = react_1.useState(function () {
        var value = typeof defaultValue === "function" ? defaultValue() : defaultValue;
        return {
            value: value,
            error: false,
            errorMessage: "",
        };
    }), state = _l[0], setState = _l[1];
    var value = state.value, error = state.error, errorMessage = state.errorMessage;
    var errored = react_1.useRef(false);
    var fieldRef = react_1.useRef(null);
    var messageId = id + "-message";
    var isCounting = counter && typeof maxLength === "number";
    var reset = react_1.useCallback(function () {
        /* istanbul ignore next */
        if (fieldRef.current) {
            fieldRef.current.setCustomValidity("");
        }
        setState({
            value: "",
            error: false,
            errorMessage: "",
        });
    }, []);
    var updateState = react_1.useCallback(function (field, isBlurEvent) {
        fieldRef.current = field;
        // need to temporarily set the `maxLength` back so it can be "verified"
        // through the validity api
        /* istanbul ignore next */
        if (isBlurEvent && disableMaxLength && typeof maxLength === "number") {
            field.maxLength = maxLength;
        }
        var value = field.value;
        field.setCustomValidity("");
        field.checkValidity();
        // remove the temporarily set `maxLength` attribute after checking the
        // validity
        /* istanbul ignore next */
        if (disableMaxLength && typeof maxLength === "number") {
            field.removeAttribute("maxLength");
        }
        var options = {
            value: value,
            pattern: pattern,
            required: required,
            minLength: minLength,
            maxLength: maxLength,
            isBlurEvent: isBlurEvent,
            validity: field.validity,
            validationMessage: field.validationMessage,
            validateOnChange: validateOnChange,
        };
        var errorMessage = getErrorMessage(options);
        var error = isErrored(__assign(__assign({}, options), { errorMessage: errorMessage }));
        if (errored.current !== error) {
            errored.current = error;
            onErrorChange(id, error);
        }
        /* istanbul ignore next */
        if (errorMessage !== field.validationMessage) {
            field.setCustomValidity(errorMessage);
        }
        setState({ value: value, error: error, errorMessage: errorMessage });
    }, [
        disableMaxLength,
        getErrorMessage,
        id,
        isErrored,
        maxLength,
        minLength,
        onErrorChange,
        pattern,
        required,
        validateOnChange,
    ]);
    var handleBlur = react_1.useCallback(function (event) {
        if (onBlur) {
            onBlur(event);
        }
        if (event.isPropagationStopped()) {
            return;
        }
        updateState(event.currentTarget, true);
    }, [onBlur, updateState]);
    var handleChange = react_1.useCallback(function (event) {
        if (onChange) {
            onChange(event);
        }
        if (event.isPropagationStopped()) {
            return;
        }
        if (!validateOnChange ||
            (Array.isArray(validateOnChange) && !validateOnChange.length)) {
            setState(function (prevState) { return (__assign(__assign({}, prevState), { value: event.currentTarget.value })); });
            return;
        }
        updateState(event.currentTarget, false);
    }, [onChange, updateState, validateOnChange]);
    var errorIcon = icon_1.useIcon("error", propErrorIcon);
    var props = {
        id: id,
        value: value,
        theme: theme,
        error: error,
        required: required,
        pattern: pattern,
        minLength: minLength,
        maxLength: disableMaxLength ? undefined : maxLength,
        rightChildren: getErrorIcon(errorMessage, error, errorIcon),
        onBlur: handleBlur,
        onChange: handleChange,
    };
    if (!disableMessage) {
        props["aria-describedby"] = messageId;
        props.messageProps = {
            id: messageId,
            error: error,
            theme: theme,
            length: counter ? value.length : undefined,
            maxLength: isCounting ? maxLength : undefined,
            children: errorMessage || helpText,
        };
    }
    return [
        value,
        props,
        {
            reset: reset,
            setState: setState,
        },
    ];
}
exports.useTextField = useTextField;
//# sourceMappingURL=useTextField.js.map