var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import React, { forwardRef, useCallback, useRef, useState, } from "react";
import cn from "classnames";
import { bem, useEnsuredRef, useResizeObserver } from "@react-md/utils";
import { useFormTheme } from "../FormThemeProvider";
import { FloatingLabel } from "../label/FloatingLabel";
import { TextFieldContainer, } from "./TextFieldContainer";
import { useFieldStates } from "../useFieldStates";
var block = bem("rmd-textarea");
var container = bem("rmd-textarea-container");
var PADDING_VARIABLES = "var(--rmd-form-text-padding-top, 0px) + var(--rmd-form-textarea-padding, 0px)";
// this is the default of 1.5rem line-height in the styles
var DEFAULT_LINE_HEIGHT = "24";
export var TextArea = forwardRef(function TextArea(_a, forwardedRef) {
    var style = _a.style, className = _a.className, areaStyle = _a.areaStyle, areaClassName = _a.areaClassName, containerRef = _a.containerRef, containerProps = _a.containerProps, label = _a.label, labelStyle = _a.labelStyle, labelClassName = _a.labelClassName, _b = _a.rows, rows = _b === void 0 ? 2 : _b, _c = _a.maxRows, maxRows = _c === void 0 ? -1 : _c, _d = _a.resize, resize = _d === void 0 ? "auto" : _d, propTheme = _a.theme, _e = _a.dense, dense = _e === void 0 ? false : _e, _f = _a.inline, propInline = _f === void 0 ? false : _f, _g = _a.error, error = _g === void 0 ? false : _g, _h = _a.disabled, disabled = _h === void 0 ? false : _h, _j = _a.animate, animate = _j === void 0 ? true : _j, _k = _a.isLeftAddon, isLeftAddon = _k === void 0 ? true : _k, _l = _a.isRightAddon, isRightAddon = _l === void 0 ? true : _l, propUnderlineDirection = _a.underlineDirection, propOnBlur = _a.onBlur, propOnFocus = _a.onFocus, propOnChange = _a.onChange, leftChildren = _a.leftChildren, rightChildren = _a.rightChildren, props = __rest(_a, ["style", "className", "areaStyle", "areaClassName", "containerRef", "containerProps", "label", "labelStyle", "labelClassName", "rows", "maxRows", "resize", "theme", "dense", "inline", "error", "disabled", "animate", "isLeftAddon", "isRightAddon", "underlineDirection", "onBlur", "onFocus", "onChange", "leftChildren", "rightChildren"]);
    var id = props.id, value = props.value, defaultValue = props.defaultValue;
    var _m = useFormTheme({
        theme: propTheme,
        underlineDirection: propUnderlineDirection,
    }), theme = _m.theme, underlineDirection = _m.underlineDirection;
    var _o = useState(), height = _o[0], setHeight = _o[1];
    if (resize !== "auto" && typeof height === "number") {
        setHeight(undefined);
    }
    var maskRef = useRef(null);
    var _p = useState(false), scrollable = _p[0], setScrollable = _p[1];
    var updateHeight = useCallback(function () {
        var mask = maskRef.current;
        /* istanbul ignore if */
        if (!mask) {
            return;
        }
        var nextHeight = mask.scrollHeight;
        /* istanbul ignore if */
        if (maxRows > 0) {
            var lineHeight = parseFloat(window.getComputedStyle(mask).lineHeight || DEFAULT_LINE_HEIGHT);
            var maxHeight = maxRows * lineHeight;
            nextHeight = Math.min(maxHeight, nextHeight);
            // only want the textarea to be scrollable if there's a limit on the rows
            // since it'll flash the scrollbar on most OS during the height transition
            if (nextHeight === maxHeight && !scrollable) {
                setScrollable(true);
            }
            else if (nextHeight !== maxHeight && scrollable) {
                setScrollable(false);
            }
        }
        if (height !== nextHeight) {
            setHeight(nextHeight);
        }
    }, [height, maxRows, scrollable]);
    // the window can be resized while there is text inside the textarea so need to
    // recalculate the height when the width changes as well.
    var _q = useResizeObserver(updateHeight, {
        ref: maskRef,
        disableHeight: true,
    }), maskRefHandler = _q[1];
    var _r = useFieldStates({
        onBlur: propOnBlur,
        onFocus: propOnFocus,
        onChange: function (event) {
            var mask = maskRef.current;
            if (propOnChange) {
                propOnChange(event);
            }
            /* istanbul ignore if */
            if (!mask || resize !== "auto") {
                return;
            }
            // to get the height transition to work, you have to set the height on:
            // - the main container element (including padding) that has the height
            //    transition enabled
            // - a child div wrapper (without padding) that has the height transition
            //    enabled
            // - the textarea element (without padding) and without a height transition
            //
            // if it isn't done this way, the height transition will look weird since
            // the text will be fixed to the bottom of the area and more text at the top
            // will become visible as the height transition completes. applying the
            // transition on the two parent elements work because:
            // - the height is set immediately on the text field so it expands to show all
            //    the text
            // - the height is correctly applied to both parent elements, but their height
            //    haven't fully been adjusted due to the animation
            // - the parent divs have overflow visible by default, so the textarea's text
            //    will expand past the boundaries of the divs and not cause the upwards
            //    animation weirdness.
            mask.value = event.currentTarget.value;
            updateHeight();
        },
        value: value,
        defaultValue: defaultValue,
    }), valued = _r.valued, focused = _r.focused, onBlur = _r.onBlur, onFocus = _r.onFocus, onChange = _r.onChange;
    var _s = useEnsuredRef(forwardedRef), ref = _s[0], refHandler = _s[1];
    // the container element adds some padding so that the content can scroll and
    // not be covered by the floating label. unfortunately, this means that the entire
    // container is no longer clickable to focus the input. This is used to add that
    // functionality back.
    var handleClick = useCallback(function (event) {
        if (ref.current && event.target === event.currentTarget) {
            ref.current.focus();
        }
    }, [ref]);
    var area = (React.createElement("textarea", __assign({}, props, { ref: refHandler, rows: rows, disabled: disabled, onFocus: onFocus, onBlur: onBlur, onChange: onChange, style: __assign(__assign({}, areaStyle), { height: height }), className: cn(block({
            scrollable: scrollable || resize === "none",
            floating: label && theme !== "none",
            rh: resize === "horizontal",
            rv: resize === "vertical",
            rn: resize === "auto" || resize === "none",
        }), areaClassName) })));
    var children = area;
    if (resize === "auto") {
        children = (React.createElement("div", { style: { height: height }, className: container("inner", { animate: animate }) },
            area,
            React.createElement("textarea", { "aria-hidden": true, defaultValue: value || defaultValue, id: id + "-mask", ref: maskRefHandler, readOnly: true, rows: rows, tabIndex: -1, style: areaStyle, className: cn(block({
                    rn: true,
                    mask: true,
                    floating: label && theme !== "none",
                }), areaClassName) })));
    }
    var inline = propInline;
    if (resize === "horizontal" || resize === "both") {
        // have to force it inline or else you won't be able to resize
        // it horizontally.
        inline = true;
    }
    return (React.createElement(TextFieldContainer, __assign({}, containerProps, { style: __assign(__assign({}, style), { height: height
                ? "calc(" + PADDING_VARIABLES + " + " + height + "px)"
                : undefined }), className: cn(container({
            animate: animate && resize === "auto",
            cursor: !disabled,
        }), className), ref: containerRef, theme: theme, error: error, active: focused, label: !!label, dense: dense, inline: inline, disabled: disabled, isLeftAddon: isLeftAddon, isRightAddon: isRightAddon, leftChildren: leftChildren, rightChildren: rightChildren, underlineDirection: underlineDirection, onClick: !disabled ? handleClick : undefined }),
        React.createElement(FloatingLabel, { style: labelStyle, className: labelClassName, htmlFor: id, error: error, active: focused, floating: focused || valued, valued: valued, dense: dense, disabled: disabled }, label),
        children));
});
/* istanbul ignore next */
if (process.env.NODE_ENV !== "production") {
    try {
        var PropTypes = require("prop-types");
        TextArea.propTypes = {
            id: PropTypes.string.isRequired,
            style: PropTypes.object,
            className: PropTypes.string,
            areaStyle: PropTypes.object,
            areaClassName: PropTypes.string,
            labelStyle: PropTypes.object,
            labelClassName: PropTypes.string,
            label: PropTypes.node,
            value: PropTypes.string,
            defaultValue: PropTypes.string,
            theme: PropTypes.oneOf(["none", "underline", "filled", "outline"]),
            dense: PropTypes.bool,
            error: PropTypes.bool,
            inline: PropTypes.bool,
            disabled: PropTypes.bool,
            placeholder: PropTypes.string,
            underlineDirection: PropTypes.oneOf(["left", "center", "right"]),
            leftChildren: PropTypes.node,
            rightChildren: PropTypes.node,
            isLeftAddon: PropTypes.bool,
            isRightAddon: PropTypes.bool,
            animate: PropTypes.bool,
            rows: PropTypes.number,
            maxRows: PropTypes.number,
            resize: PropTypes.oneOf([
                "none",
                "auto",
                "horizontal",
                "vertical",
                "both",
            ]),
            containerRef: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
            onBlur: PropTypes.func,
            onFocus: PropTypes.func,
            onChange: PropTypes.func,
        };
    }
    catch (e) { }
}
//# sourceMappingURL=TextArea.js.map