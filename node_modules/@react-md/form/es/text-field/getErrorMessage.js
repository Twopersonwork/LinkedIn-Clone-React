var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
/**
 * @internal
 * @remarks \@since 2.5.0
 */
var VALIDITY_STATE_KEYS = [
    "badInput",
    "customError",
    "patternMismatch",
    "rangeOverflow",
    "rangeUnderflow",
    "stepMismatch",
    "tooLong",
    "tooShort",
    "typeMismatch",
    "valueMissing",
];
/**
 * @internal
 * @remarks \@since 2.5.0
 */
export var RECOMMENDED_STATE_KEYS = [
    "badInput",
    "tooLong",
    "valueMissing",
];
/**
 * @internal
 * @remarks \@since 2.5.0
 */
export var RECOMMENDED_NUMBER_STATE_KEYS = __spreadArray(__spreadArray([], RECOMMENDED_STATE_KEYS), [
    "rangeOverflow",
    "rangeUnderflow",
    "tooShort",
    "typeMismatch",
]);
/**
 * The validation message is actually kind of weird since it's possible for a
 * form element to have multiple errors at once. The validation message will be
 * the first error that appears, so need to make sure that the first error is
 * one of the recommended state keys so the message appears for only those types
 * of errors.
 *
 * @internal
 * @remarks \@since 2.5.0
 */
var isRecommended = function (validity, isNumber) {
    var errorable = isNumber
        ? RECOMMENDED_NUMBER_STATE_KEYS
        : RECOMMENDED_STATE_KEYS;
    return VALIDITY_STATE_KEYS.every(function (key) {
        var errored = validity[key];
        return !errored || errorable.includes(key);
    });
};
/**
 * The default implementation for getting an error message for the `TextField`
 * or `TextArea` components that relies on the behavior of the
 * {@link ChangeValidationBehavior}
 *
 * @remarks \@since 2.5.0
 */
export var defaultGetErrorMessage = function (_a) {
    var isBlurEvent = _a.isBlurEvent, validity = _a.validity, validationMessage = _a.validationMessage, validateOnChange = _a.validateOnChange;
    if (isBlurEvent || !validationMessage || validateOnChange === true) {
        return validationMessage;
    }
    if (!validateOnChange) {
        return "";
    }
    if (validateOnChange === "recommended" ||
        validateOnChange === "number-recommended") {
        return isRecommended(validity, validateOnChange === "number-recommended")
            ? validationMessage
            : "";
    }
    var keys = typeof validateOnChange === "string"
        ? [validateOnChange]
        : validateOnChange;
    return keys.length &&
        VALIDITY_STATE_KEYS.some(function (key) { return validity[key] && keys.includes(key); })
        ? validationMessage
        : "";
};
//# sourceMappingURL=getErrorMessage.js.map