var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { createContext, useCallback, useContext, useEffect, useMemo, useRef, useState, } from "react";
import { useResizeObserver } from "@react-md/utils";
var TAB_WIDTH_VAR = "--rmd-tab-width";
var TAB_OFFSET_VAR = "--rmd-tab-offset";
var getActiveTab = function (itemRefs, activeIndex) {
    return (itemRefs[activeIndex] && itemRefs[activeIndex].current) || null;
};
/**
 * @remarks \@since 2.3.0
 * @internal
 */
var context = createContext(function () {
    // do nothing
});
/**
 * @remarks \@since 2.3.0
 * @internal
 */
export var UpdateIndicatorStylesProvider = context.Provider;
/**
 * @remarks \@since 2.3.0
 * @internal
 */
export function useUpdateIndicatorStyles() {
    return useContext(context);
}
/**
 * This hook will merge the provided style object along with the required css
 * variables for the active tab underline moving to the correct location. The
 * indicator will be updated to be the same width as the tab along with offset
 * by all the tabs' sizes.
 *
 * @internal
 */
export function useTabIndicatorStyle(_a) {
    var style = _a.style, propRef = _a.ref, align = _a.align, itemRefs = _a.itemRefs, totalTabs = _a.totalTabs, activeIndex = _a.activeIndex;
    var _b = useState(function () {
        var _a;
        var tabWidth = 100 / totalTabs + "%";
        return _a = {},
            _a[TAB_WIDTH_VAR] = tabWidth,
            _a[TAB_OFFSET_VAR] = "calc(" + activeIndex + " * " + tabWidth + ")",
            _a;
    }), cssVars = _b[0], setCSSVars = _b[1];
    var prevCSSVars = useRef(cssVars);
    var updateCSSVars = useCallback(function (itemRefs, activeIndex) {
        var _a;
        var activeTab = getActiveTab(itemRefs, activeIndex);
        if (!activeTab) {
            return;
        }
        var nextCSSVars = (_a = {},
            _a[TAB_WIDTH_VAR] = activeTab.offsetWidth + "px",
            _a[TAB_OFFSET_VAR] = activeTab.offsetLeft + "px",
            _a);
        var cssVars = prevCSSVars.current;
        if (cssVars[TAB_WIDTH_VAR] !== nextCSSVars[TAB_WIDTH_VAR] ||
            cssVars[TAB_OFFSET_VAR] !== nextCSSVars[TAB_OFFSET_VAR]) {
            prevCSSVars.current = nextCSSVars;
            setCSSVars(nextCSSVars);
        }
    }, []);
    useEffect(function () {
        updateCSSVars(itemRefs, activeIndex);
        // has to also be triggered for align changes since the indicator offset
        // will be incorrect for that.
    }, [activeIndex, itemRefs, updateCSSVars, align]);
    var updateStyles = useCallback(function () {
        updateCSSVars(itemRefs, activeIndex);
    }, [itemRefs, activeIndex, updateCSSVars]);
    // whenever the tabs container element is resized, it _probably_ means
    // that the tabs will be resized or moved. this means the indicator will
    // be in the wrong place so we need to fix it here.
    var _c = useResizeObserver(updateStyles, {
        ref: propRef,
    }), tabsRef = _c[0], tabsRefHandler = _c[1];
    var mergedStyle = useMemo(function () { return (__assign(__assign({}, style), cssVars)); }, [
        style,
        cssVars,
    ]);
    return [mergedStyle, tabsRefHandler, tabsRef, updateStyles];
}
//# sourceMappingURL=useTabIndicatorStyle.js.map