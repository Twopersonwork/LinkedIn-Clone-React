"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ListItemChildren = void 0;
var react_1 = __importDefault(require("react"));
var ListItemAddon_1 = require("./ListItemAddon");
var ListItemText_1 = require("./ListItemText");
/**
 * The `ListItemChildren` component is used to create a styled list item that
 * can have optional addons to the left or right of the children in the form of
 * icons, avatars, or media. The `children` can be replaced by the `primaryText`
 * and `secondaryText` props to create stacked text spanning two or more lines
 * with the default behavior of using `line-clamp` at three lines.
 *
 * Note: This will return a `React.Fragment` of the children and does not wrap
 * in a DOM node for styling. The parent component should normally have
 * `display: flex` for the styling to work.
 */
function ListItemChildren(_a) {
    var textClassName = _a.textClassName, secondaryTextClassName = _a.secondaryTextClassName, textChildren = _a.textChildren, primaryText = _a.primaryText, secondaryText = _a.secondaryText, leftAddon = _a.leftAddon, _b = _a.leftAddonType, leftAddonType = _b === void 0 ? "icon" : _b, _c = _a.leftAddonPosition, leftAddonPosition = _c === void 0 ? "middle" : _c, rightAddon = _a.rightAddon, _d = _a.rightAddonType, rightAddonType = _d === void 0 ? "icon" : _d, _e = _a.rightAddonPosition, rightAddonPosition = _e === void 0 ? "middle" : _e, forceAddonWrap = _a.forceAddonWrap, propChildren = _a.children;
    var stringifiedChildren = typeof propChildren === "number" ? "" + propChildren : propChildren;
    var children = stringifiedChildren;
    if (primaryText || secondaryText || textChildren) {
        children = (react_1.default.createElement(ListItemText_1.ListItemText, { className: textClassName, secondaryText: secondaryText, secondaryTextClassName: secondaryTextClassName }, (textChildren && children) || primaryText));
    }
    children = (react_1.default.createElement(ListItemAddon_1.ListItemAddon, { addon: leftAddon, type: leftAddonType, position: leftAddonPosition, forceAddonWrap: forceAddonWrap }, children));
    children = (react_1.default.createElement(ListItemAddon_1.ListItemAddon, { addon: rightAddon, addonAfter: true, type: rightAddonType, position: rightAddonPosition, forceAddonWrap: forceAddonWrap }, children));
    return (react_1.default.createElement(react_1.default.Fragment, null,
        children,
        (primaryText && stringifiedChildren) || null));
}
exports.ListItemChildren = ListItemChildren;
/* istanbul ignore next */
if (process.env.NODE_ENV !== "production") {
    try {
        var PropTypes = require("prop-types");
        ListItemChildren.propTypes = {
            textClassName: PropTypes.string,
            secondaryTextClassName: PropTypes.string,
            textChildren: PropTypes.bool,
            primaryText: PropTypes.node,
            secondaryText: PropTypes.node,
            leftAddon: PropTypes.node,
            leftAddonType: PropTypes.oneOf([
                "icon",
                "avatar",
                "media",
                "large-media",
            ]),
            leftAddonPosition: PropTypes.oneOf(["top", "middle", "bottom"]),
            rightAddon: PropTypes.node,
            rightAddonType: PropTypes.oneOf([
                "icon",
                "avatar",
                "media",
                "large-media",
            ]),
            rightAddonPosition: PropTypes.oneOf(["top", "middle", "bottom"]),
            forceAddonWrap: PropTypes.bool,
            children: PropTypes.node,
        };
    }
    catch (e) { }
}
//# sourceMappingURL=ListItemChildren.js.map