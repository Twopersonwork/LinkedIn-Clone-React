"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useMessageQueue = exports.reducer = exports.handleAddMessage = exports.resetQueue = exports.popMessage = exports.addMessage = exports.RESET_QUEUE = exports.POP_MESSAGE = exports.ADD_MESSAGE = void 0;
var react_1 = require("react");
var utils_1 = require("@react-md/utils");
var MessageQueueContext_1 = require("./MessageQueueContext");
var useWindowBlurPause_1 = require("./useWindowBlurPause");
exports.ADD_MESSAGE = "ADD_MESSAGE";
exports.POP_MESSAGE = "POP_MESSAGE";
exports.RESET_QUEUE = "RESET_QUEUE";
/**
 * @internal
 */
function addMessage(message, duplicates) {
    return { type: exports.ADD_MESSAGE, message: message, duplicates: duplicates };
}
exports.addMessage = addMessage;
/**
 * @internal
 */
var popMessage = function () { return ({ type: exports.POP_MESSAGE }); };
exports.popMessage = popMessage;
/**
 * @internal
 */
var resetQueue = function () { return ({ type: exports.RESET_QUEUE }); };
exports.resetQueue = resetQueue;
/**
 * This function is used to update the message queue state by adding a new
 * message when needed.
 *
 * @internal
 */
function handleAddMessage(state, message, duplicates) {
    if (state.length === 0) {
        return [message];
    }
    var messageId = message.messageId, _a = message.messagePriority, messagePriority = _a === void 0 ? "normal" : _a;
    var i = state.findIndex(function (mes) { return mes.messageId === messageId; });
    var isNext = messagePriority === "next";
    var isNormal = messagePriority === "normal";
    var isReplace = messagePriority === "replace";
    var isImmediate = messagePriority === "immediate";
    var isDuplicable = duplicates === "allow";
    var isRestart = duplicates === "restart";
    if (isNext || isImmediate) {
        var nextState = state.slice();
        // remove the existing message if duplicated messages aren't allowed. This
        // will kind of act like a replace + next behavior
        if (!isDuplicable && i > 0) {
            nextState.splice(i, 1);
        }
        var current = nextState[0], remaining = nextState.slice(1);
        if (isImmediate && current.messagePriority !== "immediate") {
            return __spreadArray([current, message, current], remaining);
        }
        return __spreadArray([current, message], remaining);
    }
    if (i === -1 || (isDuplicable && isNormal)) {
        return __spreadArray(__spreadArray([], state), [message]);
    }
    if (isNormal) {
        if (isRestart) {
            // creating a new state so that the queue visibility hook can still be
            // triggered which will restart the timer
            return state.slice();
        }
        return state;
    }
    if (isReplace) {
        var nextState = state.slice();
        nextState[i] = message;
        return nextState;
    }
    return __spreadArray(__spreadArray([], state), [message]);
}
exports.handleAddMessage = handleAddMessage;
/**
 * @internal
 */
function reducer(state, action) {
    switch (action.type) {
        case exports.ADD_MESSAGE:
            return handleAddMessage(state, action.message, action.duplicates);
        case exports.POP_MESSAGE:
            return state.length ? state.slice(1) : state;
        case exports.RESET_QUEUE:
            return state.length ? [] : state;
        default:
            return state;
    }
}
exports.reducer = reducer;
/**
 * This is the main logic for the message queue behavior that will handle:
 *
 * - creating timeouts as needed to show/hide toasts within the `SnackbarQueue`
 *   component
 * - create a way to push messages with optional priority onto the queue
 *
 * @internal
 */
function useMessageQueue(_a) {
    var _b = _a.timeout, timeout = _b === void 0 ? MessageQueueContext_1.DEFAULT_MESSAGE_QUEUE_TIMEOUT : _b, _c = _a.duplicates, duplicates = _c === void 0 ? "allow" : _c, _d = _a.defaultQueue, defaultQueue = _d === void 0 ? [] : _d;
    var _e = react_1.useReducer(function (state, action) { return reducer(state, action); }, defaultQueue), queue = _e[0], dispatch = _e[1];
    var queueRef = react_1.useRef(queue);
    var addMessageDispatch = react_1.useCallback(function (message) {
        if (duplicates !== "allow" && !message.messageId) {
            throw new Error("A messageId is required when the \"" + duplicates + "\" duplicate behavior is enabled but it was not provided in the current message.");
        }
        dispatch({ type: exports.ADD_MESSAGE, message: message, duplicates: duplicates });
    }, [duplicates]);
    var popMessageDispatch = react_1.useCallback(function () {
        dispatch(exports.popMessage());
    }, []);
    var resetQueueDispatch = react_1.useCallback(function () {
        dispatch(exports.resetQueue());
        return queueRef.current;
    }, []);
    var _f = utils_1.useToggle(defaultQueue.length > 0), visible = _f[0], showMessage = _f[1], hideMessage = _f[2];
    var _g = utils_1.useTimeout(hideMessage, timeout), startTimer = _g[0], stopTimer = _g[1], restartTimer = _g[2];
    react_1.useEffect(function () {
        // this effect will handle all the "logic" for transitioning between each
        // message along with the message priority updates.
        var message = queue[0], nextMessage = queue[1];
        if (!message) {
            return;
        }
        var prevQueue = queueRef.current;
        var prevMessage = prevQueue[0];
        if (message.messagePriority !== "immediate" &&
            nextMessage &&
            nextMessage.messagePriority === "immediate") {
            stopTimer();
            if (!visible) {
                popMessageDispatch();
                return;
            }
            hideMessage();
            return;
        }
        if (!visible) {
            showMessage();
        }
        if (queue.length === prevQueue.length && message === prevMessage) {
            restartTimer();
        }
        // only want to run this on queue changes
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [queue]);
    useWindowBlurPause_1.useWindowBlurPause({
        startTimer: startTimer,
        stopTimer: stopTimer,
        visible: visible,
        message: queue[0],
    });
    react_1.useEffect(function () {
        queueRef.current = queue;
    });
    return {
        queue: queue,
        resetQueue: resetQueueDispatch,
        visible: visible,
        hideMessage: hideMessage,
        addMessage: addMessageDispatch,
        popMessage: popMessageDispatch,
        startTimer: startTimer,
        stopTimer: stopTimer,
        restartTimer: restartTimer,
    };
}
exports.useMessageQueue = useMessageQueue;
//# sourceMappingURL=useMessageQueue.js.map