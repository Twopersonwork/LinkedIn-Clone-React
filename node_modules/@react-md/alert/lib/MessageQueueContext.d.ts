import { ReactNode } from "react";
import { ButtonProps } from "@react-md/button";
import { ToastProps } from "./Toast";
export declare const DEFAULT_MESSAGE_QUEUE_TIMEOUT = 5000;
export declare type DuplicateBehavior = "restart" | "prevent" | "allow";
export declare type MessagePriority = "normal" | "next" | "immediate" | "replace";
export interface Message {
    /**
     * If you have not enabled the prevent duplicated messages or the restart
     * message display timer functionality, this property can be omitted since it
     * is only used for those flows.
     *
     * When the `addMessage` action is called, the existing queue will be checked
     * for a message containing the new message's id. If it exists, it will not be
     * re-added to the queue. If the current message is being displayed, the
     * display timer will be restarted.
     */
    messageId?: string | number;
    /**
     * An optional priority to set to the message if this message needs to be
     * shown to the user more quickly. The default behavior will be to add it to
     * the end of the message queue, but when the priority is set to `"next"` it
     * will be shown immediately if there are no messages being displayed or
     * immediately after the current displayed message is hidden. All other
     * existing messages will maintain their order but pushed behind this new
     * message.
     *
     * @defaultValue `"normal"`
     */
    messagePriority?: MessagePriority;
    /**
     * Boolean if the message should not automatically hide itself after the
     * timeout duration.  This should normally be enabled if you want to enforce
     * the user presses the action inside or it is a toast that will be hidden by
     * some other logic (like online/offline).
     *
     * @defaultValue `false`
     */
    disableAutohide?: boolean;
}
export interface ToastMessage extends Message, Omit<ToastProps, "visible" | "action"> {
    /**
     * This can either be an object of button props to apply to a Button or a
     * ReactNode that will be rendered within a button.
     */
    action?: ButtonProps | ReactNode;
    /**
     * Boolean if the action button should not automatically hide the toast once
     * clicked.
     */
    disableActionHide?: boolean;
}
/**
 * This function is used to add a message to the queue.
 */
export declare type AddMessage<M extends Message> = (message: M) => void;
/**
 * @internal
 */
export declare const AddMessageContext: import("react").Context<AddMessage<Message>>;
/**
 * @internal
 */
export declare const MessageVisibilityContext: import("react").Context<boolean>;
/**
 * This hook is used to add a message to the queue from anywhere in your app.
 * This should normally be used from click event handlers, but can also be
 * triggered with custom logic within components.
 */
export declare function useAddMessage<M extends Message = ToastMessage>(): AddMessage<M>;
/**
 * Gets the current message visibility to provide to the toast.
 *
 * @internal
 */
export declare function useMessageVisibility(): boolean;
/**
 * This function is used to immediately remove the current message from the
 * queue without an exit animation.
 */
export declare type PopMessage = () => void;
/**
 * This function is used to trigger the exit animation for the current message.
 * Once the animation finishes, the `PopMessage` function will be called to
 * remove it from the queue.
 */
export declare type HideMessage = () => void;
/**
 * This function will start the visibility timer for the current message. The
 * default behavior is to start the timer once the message finishes its' enter
 * animation. Once the timeout finished, the `HideMessage` function will be
 * called to start the exit animation.
 */
export declare type StartVisibilityTimer = () => void;
/**
 * This function will stop the visibility timer for the current message. This is
 * nice to use when the browser is blurred while a toast is visible and then
 * trigger the `RestartVisibilityTimer` once the focus is returned so that
 * toasts are not shown and hidden without the user being aware.
 */
export declare type StopVisibilityTimer = () => void;
/**
 * This function will restart the visibility timer. This is useful for handling
 * duplicate messages or browser focus loss/gain behavior.
 */
export declare type RestartVisibilityTimer = () => void;
/**
 * This will allow you to reset the entire queue and immediately hide all
 * notifications. This will return the current queue at the time of reset if you
 * would like to do some manual logic for adding items to the queue.
 */
export declare type ResetQueue<M extends Message> = () => M[];
/**
 * @internal
 */
export interface MessageQueueActions<M extends Message> {
    popMessage: PopMessage;
    hideMessage: HideMessage;
    startTimer: StartVisibilityTimer;
    stopTimer: StopVisibilityTimer;
    restartTimer: RestartVisibilityTimer;
    resetQueue: ResetQueue<M>;
}
/**
 * @internal
 */
export declare const MessageQueueActionsContext: import("react").Context<MessageQueueActions<Message>>;
/**
 * This hook exposes some of the lower level actions for handling a message
 * queue if advanced behavior is desired.
 */
export declare function useMessageQueueActions<M extends Message>(): MessageQueueActions<M>;
/**
 * @internal
 */
export declare const MessageQueueContext: import("react").Context<Message[]>;
/**
 * This hook will allow you to get the current queue. This probably shouldn't be
 * used that much.
 */
export declare function useQueue<M extends Message>(): M[];
