import { BaseTreeItem, TreeData, TreeItemId, TreeItemSorter } from "./types";
/**
 * @internal
 */
export declare type NestedTreeItem<T extends BaseTreeItem> = T & {
    childItems?: NestedTreeItem<T>[];
};
/**
 * This util performantly builds a nested list of tree items from a giant flat
 * list of items by linking items together with the provided `parentId`. This
 * will also recursively build the tree and _hopefully_ all items will be added.
 *
 * If there are no children for a specific item
 *
 * TODO: Add a dev-only warning/error if the tree is built, but there are some
 * items that never referenced another `itemId`
 *
 * @internal
 */
export declare function buildTree<T extends BaseTreeItem>(parentId: null | TreeItemId, items: T[], sort?: TreeItemSorter<T>): NestedTreeItem<T>[] | undefined;
/**
 * This is an internal hook that will create a renderable nested list view of
 * the tree data.
 *
 * @internal
 * @param tree - The full tree to convert to a nested list representation
 * @param sort - An optional function that sorts the items at each level
 * @param rootId - The starting `parentId` to use while building the tree. This
 * defaults to `null` since this is most likely the general use case, but if
 * there's a different unique identifier for the "root level" items, that can be
 * used instead.
 */
export declare function useNestedTreeList<T extends BaseTreeItem>(tree: TreeData<T>, sort?: TreeItemSorter<T>, rootId?: null | TreeItemId): readonly NestedTreeItem<T>[];
