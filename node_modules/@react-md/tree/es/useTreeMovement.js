var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
import { useCallback, useRef, } from "react";
import { JumpMovementKey, MovementPresets, scrollIntoView, useActiveDescendantMovement, useIsUserInteractionMode, } from "@react-md/utils";
import { useFlattenedTreeList, } from "./useFlattenedTreeList";
import { useNestedTreeList } from "./useNestedTreeList";
/**
 * This is a temporary workaround for allowing the navigation tree to scroll
 * correctly with keyboard movement since it manually sets the
 * `overflow: visible` which prevents scrolling. I'll need to think of a better
 * way to find/get the scrollable element (if any). It might also just go into
 * the `scrollIntoView` util.
 *
 * @remarks \@since 2.5.3
 * @internal
 */
var getScrollContainer = function (target) {
    if (target.classList.contains("rmd-layout-tree")) {
        return target.parentElement;
    }
    return target;
};
/**
 * This hook handles all the complex and "fun" stuff for selecting keyboard
 * accessibility within a tree and enabling keyboard movement, selection, and
 * expansion.
 *
 * @internal
 */
export function useTreeMovement(_a) {
    var id = _a.id, data = _a.data, rootId = _a.rootId, sort = _a.sort, onBlur = _a.onBlur, onFocus = _a.onFocus, onKeyDown = _a.onKeyDown, multiSelect = _a.multiSelect, selectedIds = _a.selectedIds, onItemSelect = _a.onItemSelect, onMultiItemSelect = _a.onMultiItemSelect, expandedIds = _a.expandedIds, onItemExpansion = _a.onItemExpansion, onMultiItemExpansion = _a.onMultiItemExpansion, valueKey = _a.valueKey, getItemValue = _a.getItemValue;
    var items = useNestedTreeList(data, sort, rootId);
    var _b = useFlattenedTreeList({
        id: id,
        items: items,
        expandedIds: expandedIds,
        rootId: rootId,
        valueKey: valueKey,
        getItemValue: getItemValue,
    }), visibleItems = _b[0], itemIdRefs = _b[1], flattenedItems = _b[2];
    var isKeyboard = useIsUserInteractionMode("keyboard");
    var _c = useActiveDescendantMovement(__assign(__assign({}, MovementPresets.VERTICAL_TREE), { items: visibleItems, baseId: id, getId: function (_baseId, index) {
            return (visibleItems[index] || { id: "" }).id;
        },
        onSpace: function (focusedIndex) {
            var item = visibleItems[focusedIndex];
            if (!item) {
                return;
            }
            var itemId = item.itemId;
            onItemSelect(itemId);
        },
        onChange: function (data) {
            var index = data.index, target = data.target, query = data.query;
            var itemId = visibleItems[index].itemId;
            // Note: have to do a custom `scrollIntoView` here instead of relying on
            // the `useActiveDescendantMovement`'s `scrollIntoView` because of how the
            // tree renders with the ref behavior.
            var item = itemIdRefs[itemId].ref.current;
            var container = getScrollContainer(target);
            if (item &&
                container &&
                container.scrollHeight > container.offsetHeight) {
                scrollIntoView(container, item);
            }
            if (!multiSelect) {
                return;
            }
            var isToStart = query.endsWith(JumpMovementKey.ControlShiftHome);
            var isToEnd = query.endsWith(JumpMovementKey.ControlShiftEnd);
            if (!isToStart && !isToEnd) {
                return;
            }
            var start = isToStart ? 0 : focusedIndex;
            var end = isToStart ? focusedIndex + 1 : undefined;
            var jumpSelectedIds = visibleItems
                .slice(start, end)
                .map(function (_a) {
                var itemId = _a.itemId;
                return itemId;
            });
            var uniqueSelectedIds = Array.from(new Set(__spreadArray(__spreadArray([], selectedIds), jumpSelectedIds)));
            if (selectedIds.length !== uniqueSelectedIds.length) {
                onMultiItemSelect(uniqueSelectedIds);
            }
        },
        onKeyDown: function (event) {
            var _a, _b, _c, _d;
            if (onKeyDown) {
                onKeyDown(event);
            }
            var item = visibleItems[focusedIndex];
            if (!item) {
                return;
            }
            var itemId = item.itemId, parentId = item.parentId, isParent = item.isParent;
            switch (event.key) {
                case "Enter": {
                    if (isParent) {
                        onItemExpansion(itemId, !expandedIds.includes(itemId));
                        return;
                    }
                    var node = itemIdRefs[itemId].ref.current;
                    var anchor = node &&
                        node.getAttribute("role") === "none" &&
                        node.querySelector("a[href]");
                    if (!anchor) {
                        onItemSelect(itemId);
                        return;
                    }
                    // if a user is navigating through the app with a keyboard and presses
                    // cmd+shift+enter (Mac) or ctrl+shift+enter (Windows), the link will
                    // be forcefully opened in a new tab irregardless of the target
                    // attribute on the anchor tag. Since a tree doesn't actually focus
                    // the link in this case, need to "polyfill" it with this workaround.
                    // the `meta` key is for Mac and `ctrlKey` for Windows
                    var forceNewTab = event.shiftKey && (event.metaKey || event.ctrlKey);
                    var prevTarget = anchor.target;
                    if (forceNewTab) {
                        anchor.target = "_blank";
                    }
                    anchor.click();
                    if (forceNewTab) {
                        anchor.target = prevTarget;
                    }
                    break;
                }
                case "ArrowRight":
                    if (!isParent) {
                        return;
                    }
                    if (!expandedIds.includes(itemId)) {
                        onItemExpansion(itemId, true);
                    }
                    else {
                        var nextIndex = focusedIndex + 1;
                        var nextItem = (_b = itemIdRefs[(_a = visibleItems[nextIndex]) === null || _a === void 0 ? void 0 : _a.itemId]) === null || _b === void 0 ? void 0 : _b.ref.current;
                        setFocusedIndex(nextIndex);
                        scrollIntoView(event.currentTarget, nextItem);
                    }
                    break;
                case "ArrowLeft":
                    if (isParent && expandedIds.includes(itemId)) {
                        onItemExpansion(itemId, false);
                    }
                    else if (parentId !== rootId) {
                        var parentIndex = visibleItems.findIndex(function (item) { return item.itemId === parentId; });
                        var parentItem = (_d = itemIdRefs[(_c = visibleItems[parentIndex]) === null || _c === void 0 ? void 0 : _c.itemId]) === null || _d === void 0 ? void 0 : _d.ref.current;
                        setFocusedIndex(parentIndex);
                        scrollIntoView(event.currentTarget, parentItem);
                    }
                    break;
                case "a": {
                    if (!multiSelect || !event.ctrlKey) {
                        return;
                    }
                    event.preventDefault();
                    var allItemIds = visibleItems.map(function (_a) {
                        var itemId = _a.itemId;
                        return itemId;
                    });
                    if (selectedIds.length === allItemIds.length) {
                        onMultiItemSelect([]);
                    }
                    else {
                        onMultiItemSelect(allItemIds);
                    }
                    break;
                }
                case "*": {
                    var item_1 = visibleItems[focusedIndex];
                    if (!item_1) {
                        return;
                    }
                    var expectedExpandedIds = visibleItems
                        .filter(function (_a) {
                        var isParent = _a.isParent, parentId = _a.parentId;
                        return isParent && parentId === item_1.parentId;
                    })
                        .map(function (_a) {
                        var itemId = _a.itemId;
                        return itemId;
                    });
                    var nextIds = Array.from(new Set(__spreadArray(__spreadArray([], expandedIds), expectedExpandedIds)));
                    if (nextIds.length !== expandedIds.length) {
                        onMultiItemExpansion(nextIds);
                        // since new items will be rendered, need to also update the focused
                        // index so the currently active item is still the "focused" item
                        //
                        // TODO: Look into a much better way to handle this sort of stuff..
                        // This still doesn't correctly scroll the active element into view.
                        // I should probably move all the scroll behavior into a useEffect
                        // for whenever the focusedIndex changes.
                        var visibleCount = 0;
                        var lookup = {};
                        for (var i = 0; i < flattenedItems.length; i += 1) {
                            var item_2 = flattenedItems[i];
                            var isVisible = item_2.parentId === rootId;
                            if (item_2.parentId !== null && nextIds.includes(item_2.parentId)) {
                                isVisible = !!lookup[item_2.parentId];
                            }
                            lookup[item_2.itemId] = isVisible;
                            if (itemId === item_2.itemId) {
                                setFocusedIndex(visibleCount);
                                return;
                            }
                            if (isVisible) {
                                visibleCount += 1;
                            }
                        }
                    }
                }
                // no default
            }
        } })), activeId = _c.activeId, handleKeyDown = _c.onKeyDown, focusedIndex = _c.focusedIndex, setFocusedIndex = _c.setFocusedIndex;
    var lastFocus = useRef(0);
    var handleBlur = useCallback(function (event) {
        if (onBlur) {
            onBlur(event);
        }
        if (document.activeElement &&
            event.currentTarget.contains(document.activeElement)) {
            return;
        }
        lastFocus.current = focusedIndex;
        setFocusedIndex(-1);
    }, [focusedIndex, onBlur, setFocusedIndex]);
    var handleFocus = useCallback(function (event) {
        var _a, _b;
        if (onFocus) {
            onFocus(event);
        }
        if (focusedIndex !== -1) {
            // this happens when a tree item is clicked with the mouse or touch
            return;
        }
        var index = -1;
        // try to "focus" the first selected itemId if there is a selection.
        if (selectedIds.length) {
            index = visibleItems.findIndex(function (item) {
                return selectedIds.includes(item.itemId);
            });
        }
        // fallback to the first visible tree item if there were no selected ids
        if (index === -1) {
            index = Math.max(0, Math.min(lastFocus.current, visibleItems.length));
        }
        var currentItem = (_b = itemIdRefs[(_a = visibleItems[index]) === null || _a === void 0 ? void 0 : _a.itemId]) === null || _b === void 0 ? void 0 : _b.ref.current;
        if (currentItem && isKeyboard) {
            scrollIntoView(getScrollContainer(event.currentTarget), currentItem);
        }
        setFocusedIndex(index);
    }, [
        focusedIndex,
        isKeyboard,
        itemIdRefs,
        onFocus,
        selectedIds,
        setFocusedIndex,
        visibleItems,
    ]);
    var setActiveId = useCallback(function (itemId) {
        var index = visibleItems.findIndex(function (item) { return item.itemId === itemId; });
        if (index !== -1) {
            setFocusedIndex(index);
        }
    }, [setFocusedIndex, visibleItems]);
    return {
        items: items,
        activeId: activeId,
        setActiveId: setActiveId,
        itemIdRefs: itemIdRefs,
        handleBlur: handleBlur,
        handleFocus: handleFocus,
        handleKeyDown: handleKeyDown,
    };
}
//# sourceMappingURL=useTreeMovement.js.map