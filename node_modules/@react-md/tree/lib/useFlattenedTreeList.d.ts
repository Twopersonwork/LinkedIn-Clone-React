import { MutableRefObject } from "react";
import { ExpandedIds, TreeItemId, TreeProps, UnknownTreeItem } from "./types";
import { NestedTreeItem } from "./useNestedTreeList";
export interface SearchableTreeItem {
    /**
     * A DOM Node `id` to use.
     */
    id: string;
    /**
     * A searchable value for the tree item.
     */
    value: string;
    isParent: boolean;
    itemId: TreeItemId;
    parentId: TreeItemId | null;
}
declare type TreeConfig = Required<Pick<TreeProps<UnknownTreeItem>, "valueKey" | "getItemValue">>;
interface Options extends TreeConfig {
    id: string;
    items: readonly NestedTreeItem<UnknownTreeItem>[];
    expandedIds: ExpandedIds;
    rootId: TreeItemId | null;
}
export declare type TreeItemRef = MutableRefObject<HTMLLIElement | null>;
export interface ItemMetadata {
    id: string;
    ref: TreeItemRef;
    visibleIndex: number;
}
export declare type MetadataRecord = Record<TreeItemId, ItemMetadata>;
declare type ReturnValue = [SearchableTreeItem[], MetadataRecord, SearchableTreeItem[]];
/**
 * Creates a flattened and ordered list of all the tree items that are current visible
 * in the DOM based on the expanded ids. This is only required for handling keyboard
 * navigation with `aria-activedescendant` movement so the items can be "focused" with
 * typeahead and keyboard movement since the keyboard movement API requires DOM refs
 * to be passed to each element.
 *
 * This flattened list will remove the `childItems` (if it existed) on each item for
 * simplicity and the child items aren't needed for this flattened list.
 *
 * @internal
 */
export declare function useFlattenedTreeList({ id, items, rootId, expandedIds, valueKey, getItemValue, }: Options): ReturnValue;
export {};
