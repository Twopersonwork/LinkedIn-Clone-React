"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useNestedTreeList = exports.buildTree = void 0;
var react_1 = require("react");
/**
 * This util performantly builds a nested list of tree items from a giant flat
 * list of items by linking items together with the provided `parentId`. This
 * will also recursively build the tree and _hopefully_ all items will be added.
 *
 * If there are no children for a specific item
 *
 * TODO: Add a dev-only warning/error if the tree is built, but there are some
 * items that never referenced another `itemId`
 *
 * @internal
 */
function buildTree(parentId, items, sort) {
    var childItems = [];
    // doing a "reverse" order filter/move so that the items array shrinks while
    // looping. This makes it so that the entire items array doesn't need to
    // continually be looped through as more items are added to the tree, only the
    // remaining items will have to be looped
    var i = items.length;
    while (i > 0) {
        i -= 1;
        if (items[i] && items[i].parentId === parentId) {
            var item = items.splice(i, 1)[0];
            // shallow cloning so childItems doesn't get applied to the original data
            // set
            childItems.unshift(__assign({}, item));
        }
    }
    if (!childItems.length) {
        return undefined;
    }
    childItems.forEach(function (childItem) {
        childItem.childItems = buildTree(childItem.itemId, items, sort);
    });
    return sort ? sort(childItems) : childItems;
}
exports.buildTree = buildTree;
/**
 * This is an internal hook that will create a renderable nested list view of
 * the tree data.
 *
 * @internal
 * @param tree - The full tree to convert to a nested list representation
 * @param sort - An optional function that sorts the items at each level
 * @param rootId - The starting `parentId` to use while building the tree. This
 * defaults to `null` since this is most likely the general use case, but if
 * there's a different unique identifier for the "root level" items, that can be
 * used instead.
 */
function useNestedTreeList(tree, sort, rootId) {
    if (rootId === void 0) { rootId = null; }
    return react_1.useMemo(function () { return buildTree(rootId, Object.values(tree), sort) || []; }, [
        rootId,
        sort,
        tree,
    ]);
}
exports.useNestedTreeList = useNestedTreeList;
//# sourceMappingURL=useNestedTreeList.js.map