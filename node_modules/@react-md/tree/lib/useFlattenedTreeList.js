"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFlattenedTreeList = void 0;
var react_1 = require("react");
var getTreeItemId_1 = require("./getTreeItemId");
function flatten(_a) {
    var list = _a.list, item = _a.item, index = _a.index, baseId = _a.baseId, parentIndexes = _a.parentIndexes, valueKey = _a.valueKey, getItemValue = _a.getItemValue;
    if (item.isCustom) {
        return list;
    }
    var id = getTreeItemId_1.getTreeItemId(baseId, index, parentIndexes);
    var value = getItemValue(item, valueKey);
    var itemId = item.itemId, parentId = item.parentId, childItems = item.childItems;
    list.push({
        id: id,
        itemId: itemId,
        parentId: parentId,
        isParent: !!childItems,
        value: value,
    });
    if (!childItems) {
        return list;
    }
    var nextIndexes = __spreadArray(__spreadArray([], parentIndexes), [index + 1]);
    childItems.forEach(function (child, childIndex) {
        flatten({
            list: list,
            item: child,
            index: childIndex,
            valueKey: valueKey,
            getItemValue: getItemValue,
            baseId: baseId,
            parentIndexes: nextIndexes,
        });
    });
    return list;
}
/**
 * Creates a flattened and ordered list of all the tree items that are current visible
 * in the DOM based on the expanded ids. This is only required for handling keyboard
 * navigation with `aria-activedescendant` movement so the items can be "focused" with
 * typeahead and keyboard movement since the keyboard movement API requires DOM refs
 * to be passed to each element.
 *
 * This flattened list will remove the `childItems` (if it existed) on each item for
 * simplicity and the child items aren't needed for this flattened list.
 *
 * @internal
 */
function useFlattenedTreeList(_a) {
    var id = _a.id, items = _a.items, rootId = _a.rootId, expandedIds = _a.expandedIds, valueKey = _a.valueKey, getItemValue = _a.getItemValue;
    var flattenedItems = react_1.useMemo(function () {
        return items.reduce(function (list, item, index) {
            return flatten({
                list: list,
                item: item,
                index: index,
                valueKey: valueKey,
                getItemValue: getItemValue,
                baseId: id,
                parentIndexes: [],
            });
        }, []);
    }, [getItemValue, id, items, valueKey]);
    var _b = react_1.useMemo(function () {
        var index = 0;
        return flattenedItems.reduce(function (collection, item) {
            var _a, _b;
            var parentId = item.parentId, itemId = item.itemId;
            var isVisible = parentId === rootId;
            if (parentId !== null && expandedIds.includes(parentId)) {
                // need to also make sure that the parent is visible
                isVisible =
                    ((_b = (_a = collection.itemRefs[parentId]) === null || _a === void 0 ? void 0 : _a.visibleIndex) !== null && _b !== void 0 ? _b : -1) !== -1;
            }
            collection.itemRefs[itemId] = {
                id: item.id,
                ref: { current: null },
                visibleIndex: isVisible ? index : -1,
            };
            if (isVisible) {
                index += 1;
                collection.visibleItems.push(item);
            }
            return collection;
        }, { visibleItems: [], itemRefs: {} });
    }, [expandedIds, flattenedItems, rootId]), visibleItems = _b.visibleItems, itemRefs = _b.itemRefs;
    return [visibleItems, itemRefs, flattenedItems];
}
exports.useFlattenedTreeList = useFlattenedTreeList;
//# sourceMappingURL=useFlattenedTreeList.js.map