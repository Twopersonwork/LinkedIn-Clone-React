"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useInteractionStates = void 0;
var classnames_1 = __importDefault(require("classnames"));
var useRipples_1 = require("./ripples/useRipples");
var StatesConfig_1 = require("./StatesConfig");
var useKeyboardClickPolyfill_1 = require("./useKeyboardClickPolyfill");
var usePressedStates_1 = require("./usePressedStates");
/**
 * This is probably one of the most useful hook in react-md. Any functional
 * component component that uses this will gain all the different interaction
 * states based on the states context or any custom overrides.
 *
 * The main interaction state is the "ripple" effect when an element has been
 * clicked either via keyboard, mouse, or touch.
 *
 * If the ripple effect is disabled, it will fallback to "polyfilling"/fixing
 * the `:pressed` pseudo-selector state for items so that a different
 * background-color opacity is applied instead of the entire ripple effect. This
 * is polyfilled since the `:pressed` state does not work on anything other than
 * buttons and links by default and it is not triggered on "valid" keyboard
 * clicks with a spacebar.
 *
 * Finally, the element that uses this hook will gain a focused className
 * whenever it gains keyboard focus only.
 *
 * To get all these interaction states to work correctly, this hook returns an
 * object containing:
 *
 * - `handlers`- an object of event handlers that must be passed down to your
 *   component to get the different interaction states. All the event handlers
 *   are automatically merged with any `handlers` that are provided to this hook
 *   so they can all be called if needed.
 * - `className` - the current class name for the element
 * - `ripples` - a renderable element that displays the ripple effects. This
 *   will be `null` when ripples are disabled.
 *
 * @typeParam E - The element type for the component being wrapped. This is
 * really just used to "better type" the event handlers.
 */
function useInteractionStates(options) {
    if (options === void 0) { options = {}; }
    var disabled = options.disabled, rippleClassName = options.rippleClassName, rippleContainerClassName = options.rippleContainerClassName, _a = options.disableSpacebarClick, disableSpacebarClick = _a === void 0 ? false : _a, _b = options.disablePressedFallback, disablePressedFallback = _b === void 0 ? false : _b, _c = options.enablePressedAndRipple, enablePressedAndRipple = _c === void 0 ? false : _c, _d = options.disableEnterClick, disableEnterClick = _d === void 0 ? false : _d;
    var className = options.className, disableRipple = options.disableRipple, disableProgrammaticRipple = options.disableProgrammaticRipple, rippleTimeout = options.rippleTimeout, rippleClassNames = options.rippleClassNames;
    // populate undefined props from their context values
    var context = StatesConfig_1.useStatesConfigContext();
    if (typeof disableRipple === "undefined") {
        (disableRipple = context.disableRipple);
    }
    if (typeof disableProgrammaticRipple === "undefined") {
        (disableProgrammaticRipple = context.disableProgrammaticRipple);
    }
    if (typeof rippleTimeout === "undefined") {
        (rippleTimeout = context.rippleTimeout);
    }
    if (typeof rippleClassNames === "undefined") {
        (rippleClassNames = context.rippleClassNames);
    }
    var handlers = null;
    var ripples = null;
    var ripplesResult = useRipples_1.useRipples(__assign(__assign({}, options), { disableSpacebarClick: disableSpacebarClick,
        disableRipple: disableRipple,
        disableProgrammaticRipple: disableProgrammaticRipple,
        rippleTimeout: rippleTimeout,
        rippleClassName: rippleClassName,
        rippleContainerClassName: rippleContainerClassName }));
    if (!disableRipple) {
        (ripples = ripplesResult.ripples, handlers = ripplesResult.handlers);
    }
    var pressedResult = usePressedStates_1.usePressedStates(__assign(__assign({}, options), { handlers: handlers || options.handlers, disableSpacebarClick: disableSpacebarClick }));
    if (enablePressedAndRipple || (disableRipple && !disablePressedFallback)) {
        (handlers = pressedResult.handlers);
        className = classnames_1.default(className, { "rmd-states--pressed": pressedResult.pressed });
    }
    handlers = handlers || options.handlers || {};
    handlers.onKeyDown = useKeyboardClickPolyfill_1.useKeyboardClickPolyfill({
        disabled: disabled,
        disableEnterClick: disableEnterClick,
        disableSpacebarClick: disableSpacebarClick,
        onKeyDown: handlers.onKeyDown,
    });
    return {
        ripples: ripples,
        className: className,
        handlers: handlers,
    };
}
exports.useInteractionStates = useInteractionStates;
//# sourceMappingURL=useInteractionStates.js.map