import { RippleEvent, RippleState, RippleType } from "./types";
/**
 * Checks if the ripple event should be ignored since it was bubbled
 * up from a child treeitem. I should find a better way to handle
 * this at some point.
 */
export declare function isBubbled<E extends HTMLElement>(event: Pick<RippleEvent<E>, "currentTarget" | "target">): boolean;
/**
 * Gets the ripple event type based on the provided event.
 */
export declare function getType(event: Pick<RippleEvent<HTMLElement>, "type">): RippleType;
/**
 * Checks if the provided event type is actually rippleable by ensuring:
 * - it is a mousedown event while not in touch mode and the left mouse was
 *   clicked.
 * - it was a keydown event for either tab or space when spacebar clicks have not
 *   been disabled
 * - it was a touchstart event
 */
export declare function isRippleable(event: RippleEvent<HTMLElement>, disableSpacebarClick: boolean): boolean;
interface Origin {
    x: number;
    y: number;
}
/**
 * Gets the ripple creation origin base on the provided event. When the event
 * type is for keyboards or triggered programmatically, the origin will
 * be the center of the target element. When the event is for touch or mouse,
 * the origin will be the location within the viewport where the user touched
 * or clicked the target element.
 */
export declare function getOrigin(event: Pick<RippleEvent<HTMLElement>, "pageX" | "pageY" | "touches" | "type">, element: HTMLElement): Origin;
/**
 * Creates a new ripple state based off the provided event type.
 */
export declare function createRippleState(event: RippleEvent<HTMLElement>): RippleState;
export {};
