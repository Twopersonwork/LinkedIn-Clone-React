"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRippleState = exports.getOrigin = exports.isRippleable = exports.getType = exports.isBubbled = void 0;
var utils_1 = require("@react-md/utils");
/**
 * Checks if the ripple event should be ignored since it was bubbled
 * up from a child treeitem. I should find a better way to handle
 * this at some point.
 */
function isBubbled(event) {
    return Array.from(event.currentTarget.querySelectorAll('[role="treeitem"]')).some(function (item) { return item.contains(event.target); });
}
exports.isBubbled = isBubbled;
/**
 * Gets the ripple event type based on the provided event.
 */
function getType(event) {
    switch (event.type) {
        case "mousedown":
        case "mouseup":
        case "mouseleave":
            return "mouse";
        case "touchstart":
        case "touchmove":
        case "touchend":
            return "touch";
        case "keydown":
        case "keyup":
            return "keyboard";
        default:
            return "programmatic";
    }
}
exports.getType = getType;
/**
 * Checks if the provided event type is actually rippleable by ensuring:
 * - it is a mousedown event while not in touch mode and the left mouse was
 *   clicked.
 * - it was a keydown event for either tab or space when spacebar clicks have not
 *   been disabled
 * - it was a touchstart event
 */
function isRippleable(event, disableSpacebarClick) {
    switch (event.type) {
        case "mousedown":
            return (document.querySelector(".rmd-states--touch") === null &&
                event.button === 0);
        case "keydown":
            return ((!disableSpacebarClick && event.key === " ") ||
                (event.key === "Enter" &&
                    !/checkbox|radio/i.test(event.currentTarget.getAttribute("type") || "")));
        case "touchstart":
        case "click":
            return true;
        default:
            return false;
    }
}
exports.isRippleable = isRippleable;
function calcHypotenuse(a, b) {
    return Math.sqrt(a * a + b * b);
}
/**
 * Gets the current radius for a ripple based on the x and y page dimensions
 * as well as the size of the element.
 *
 * This is really just in a separate file so I can easily mock this and write
 * tests.
 */
function getRadius(x, y, offsetWidth, offsetHeight) {
    return Math.max(calcHypotenuse(x, y), calcHypotenuse(offsetWidth - x, y), calcHypotenuse(offsetWidth - x, offsetHeight - y), calcHypotenuse(x, offsetHeight - y));
}
/**
 * Gets the ripple creation origin base on the provided event. When the event
 * type is for keyboards or triggered programmatically, the origin will
 * be the center of the target element. When the event is for touch or mouse,
 * the origin will be the location within the viewport where the user touched
 * or clicked the target element.
 */
function getOrigin(event, element) {
    var _a;
    var type = getType(event);
    var offsetWidth = element.offsetWidth, offsetHeight = element.offsetHeight;
    var x;
    var y;
    if (type === "programmatic" || type === "keyboard") {
        x = offsetWidth / 2;
        y = offsetHeight / 2;
    }
    else {
        // if the event type is not programmatic, want to figure out exactly where in
        // the element to trigger the animation from. this can be determined by:
        // - getting the pageX and pageY of the mouse or touch event
        // - getting element's current position in the page
        var pageX = void 0;
        var pageY = void 0;
        if (type === "mouse") {
            (_a = event, pageX = _a.pageX, pageY = _a.pageY);
        }
        else {
            var touch = event.touches.item(0);
            (pageX = touch.pageX, pageY = touch.pageY);
        }
        var rect = element.getBoundingClientRect();
        // have to include the current page's scroll offset to the element's
        // bounding rect since the pageX and pageY from Events include the scroll
        // offset while the bounding rect is only based on viewport.
        x = pageX - (rect.left + window.pageXOffset);
        y = pageY - (rect.top + window.pageYOffset);
    }
    return { x: x, y: y };
}
exports.getOrigin = getOrigin;
/**
 * Creates a new ripple state based off the provided event type.
 */
function createRippleState(event) {
    var element = utils_1.findSizingContainer(event.currentTarget) || event.currentTarget;
    var offsetWidth = element.offsetWidth, offsetHeight = element.offsetHeight;
    var type = getType(event);
    var _a = getOrigin(event, element), x = _a.x, y = _a.y;
    var radius = getRadius(x, y, offsetWidth, offsetHeight);
    var size = radius * 2;
    return {
        startTime: Date.now(),
        style: {
            left: x - radius,
            top: y - radius,
            height: size,
            width: size,
        },
        type: type,
        holding: type !== "programmatic",
        exiting: false,
        entered: false,
    };
}
exports.createRippleState = createRippleState;
//# sourceMappingURL=utils.js.map