var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { useCallback, useRef } from "react";
import { useRefCache } from "@react-md/utils";
/**
 * This hook is used to create all the event handlers required for
 * creating ripples on an element. Each handler will be memoized and
 * merged with any provided event handlers of the same type. If the
 * ripple effect is disabled, the provided event handlers will be
 * returned instead.
 */
export function useRippleHandlers(_a) {
    var create = _a.create, release = _a.release, cancel = _a.cancel, _b = _a.handlers, handlers = _b === void 0 ? {} : _b, _c = _a.disabled, propDisabled = _c === void 0 ? false : _c, _d = _a.disableRipple, disableRipple = _d === void 0 ? false : _d, _e = _a.disableProgrammaticRipple, disableProgrammaticRipple = _e === void 0 ? false : _e;
    var disabled = propDisabled || disableRipple;
    var ref = useRefCache(__assign(__assign({}, handlers), { disableProgrammaticRipple: disableProgrammaticRipple }));
    // some OS/browser don't actually focus buttons/elements that are focusable after a click
    // event which causes a double ripple effect. This ref is used to disable the programmatic
    // ripple in these cases.
    var disableProgrammatic = useRef(false);
    var onKeyDown = useCallback(function (event) {
        var callback = ref.current.onKeyDown;
        if (callback) {
            callback(event);
        }
        create(event);
    }, 
    // disabled since useRefCache
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [create]);
    var onKeyUp = useCallback(function (event) {
        var callback = ref.current.onKeyUp;
        if (callback) {
            callback(event);
        }
        release(event);
    }, 
    // disabled since useRefCache
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [release]);
    var onMouseDown = useCallback(function (event) {
        var callback = ref.current.onMouseDown;
        if (callback) {
            callback(event);
        }
        create(event);
        disableProgrammatic.current = true;
    }, 
    // disabled since useRefCache
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [create]);
    var onMouseUp = useCallback(function (event) {
        var callback = ref.current.onMouseUp;
        if (callback) {
            callback(event);
        }
        release(event);
    }, 
    // disabled since useRefCache
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [release]);
    var onMouseLeave = useCallback(function (event) {
        var callback = ref.current.onMouseLeave;
        if (callback) {
            callback(event);
        }
        cancel(true);
    }, 
    // disabled since useRefCache
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [cancel]);
    var onTouchStart = useCallback(function (event) {
        var callback = ref.current.onTouchStart;
        if (callback) {
            callback(event);
        }
        create(event);
    }, 
    // disabled since useRefCache
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [create]);
    var onTouchMove = useCallback(function (event) {
        var callback = ref.current.onTouchMove;
        if (callback) {
            callback(event);
        }
        cancel(false);
    }, 
    // disabled since useRefCache
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [cancel]);
    var onTouchEnd = useCallback(function (event) {
        var callback = ref.current.onTouchEnd;
        if (callback) {
            callback(event);
        }
        release(event);
    }, 
    // disabled since useRefCache
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [release]);
    var onClick = useCallback(function (event) {
        var _a = ref.current, callback = _a.onClick, disableProgrammaticRipple = _a.disableProgrammaticRipple;
        if (callback) {
            callback(event);
        }
        // when a click event is triggered and the current active element is not
        // the event target, we know it was a true programmatic event and should
        // trigger a ripple for it.
        if (disableProgrammaticRipple ||
            document.activeElement === event.currentTarget ||
            disableProgrammatic.current) {
            disableProgrammatic.current = false;
            return;
        }
        create(event);
    }, 
    // disabled since useRefCache
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [create]);
    return {
        onKeyDown: disabled ? handlers.onKeyDown : onKeyDown,
        onKeyUp: disabled ? handlers.onKeyUp : onKeyUp,
        onMouseDown: disabled ? handlers.onMouseDown : onMouseDown,
        onMouseUp: disabled ? handlers.onMouseUp : onMouseUp,
        onMouseLeave: disabled ? handlers.onMouseLeave : onMouseLeave,
        onTouchStart: disabled ? handlers.onTouchStart : onTouchStart,
        onTouchMove: disabled ? handlers.onTouchMove : onTouchMove,
        onTouchEnd: disabled ? handlers.onTouchEnd : onTouchEnd,
        onClick: disabled || disableProgrammaticRipple ? handlers.onClick : onClick,
    };
}
//# sourceMappingURL=useRippleHandlers.js.map