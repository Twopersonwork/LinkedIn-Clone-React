var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArray = (this && this.__spreadArray) || function (to, from) {
    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
        to[j] = from[i];
    return to;
};
import { useCallback, useReducer } from "react";
import { useRefCache } from "@react-md/utils";
import { createRippleState, getType, isBubbled, isRippleable } from "./utils";
export var CREATE = "CREATE";
export var CANCEL = "CANCEL";
export var RELEASE = "RELEASE";
export var ENTERED = "ENTERED";
export var REMOVE = "REMOVE";
/**
 * This function will create a simplified version of the create event
 * that only includes the parts that are needed to trigger a ripple.
 * This is really only required since `event.persist()` crashed a lot
 * when spamming the trigger events and it threw warnings when not
 * persisting the event.
 */
export function createRippleAction(event, disableSpacebarClick) {
    var _a = event, type = _a.type, target = _a.target, currentTarget = _a.currentTarget, touches = _a.touches, pageX = _a.pageX, pageY = _a.pageY, button = _a.button, key = _a.key;
    return {
        type: CREATE,
        disableSpacebarClick: disableSpacebarClick,
        event: {
            type: type,
            key: key,
            target: target,
            button: button,
            currentTarget: currentTarget,
            touches: touches,
            pageX: pageX,
            pageY: pageY,
        },
    };
}
function createRipple(state, event, disableSpacebarClick) {
    if (!isRippleable(event, disableSpacebarClick) || isBubbled(event)) {
        return state;
    }
    if (state.find(function (r) { return r.holding; }) ||
        (getType(event) !== "touch" && state.find(function (r) { return r.type === "touch"; }))) {
        // keyboard events are a bit different than the others since it is actually
        // spammable since the space or enter key can be held down which triggers click
        // events infinitely until they release. There's also the fun fact that mouse
        // events are triggered after touch events, so we need to make sure duplicate
        // ripples aren't created for these
        return state;
    }
    var ripple = createRippleState(event);
    return __spreadArray(__spreadArray([], state), [ripple]);
}
function enteredRipple(state, ripple) {
    var i = state.findIndex(function (r) { return r === ripple; });
    if (i === -1 || ripple.exiting) {
        return state;
    }
    var nextState = state.slice();
    var exiting = !ripple.holding || Date.now() - ripple.startTime > 300;
    nextState[i] = __assign(__assign({}, ripple), { exiting: exiting, entered: true });
    return nextState;
}
function releaseRipple(state) {
    var i = state.findIndex(function (r) { return r.holding && !r.exiting; });
    if (i === -1) {
        return state;
    }
    var ripple = state[i];
    var exiting = ripple.entered || Date.now() - ripple.startTime > 300;
    var nextState = state.slice();
    nextState[i] = __assign(__assign({}, ripple), { exiting: exiting, holding: false });
    return nextState;
}
function removeRipple(state, ripple) {
    var i = state.findIndex(function (r) { return r.startTime === ripple.startTime; });
    if (i === -1) {
        return state;
    }
    var nextState = state.slice();
    nextState.splice(i, 1);
    return nextState;
}
function cancelRipples(state, ease) {
    if (ease) {
        return state.map(function (r) { return (__assign(__assign({}, r), { exiting: true, mounted: true, holding: false })); });
    }
    return [];
}
export function reducer(state, action) {
    if (state === void 0) { state = []; }
    switch (action.type) {
        case CREATE:
            return createRipple(state, action.event, action.disableSpacebarClick);
        case RELEASE:
            return releaseRipple(state);
        case CANCEL:
            return cancelRipples(state, action.ease);
        case ENTERED:
            return enteredRipple(state, action.ripple);
        case REMOVE:
            return removeRipple(state, action.ripple);
        default:
            return state;
    }
}
/**
 * This hook creates memoized callbacks for each part of the ripple transition
 * as well as returning the current list of ripples.
 */
export function useRippleTransition(disableSpacebarClick) {
    if (disableSpacebarClick === void 0) { disableSpacebarClick = false; }
    var _a = useReducer(reducer, []), state = _a[0], dispatch = _a[1];
    var spacebarRef = useRefCache(disableSpacebarClick);
    var create = useCallback(function (event) {
        var disableSpacebarClick = spacebarRef.current;
        dispatch(createRippleAction(event, disableSpacebarClick));
        // disabled since useRefCache
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    var release = useCallback(function (event) {
        dispatch({ type: RELEASE, event: event });
    }, []);
    var entered = useCallback(function (ripple) {
        dispatch({ type: ENTERED, ripple: ripple });
    }, []);
    var cancel = useCallback(function (ease) {
        if (ease === void 0) { ease = false; }
        dispatch({ type: CANCEL, ease: ease });
    }, []);
    var remove = useCallback(function (ripple) {
        dispatch({ type: REMOVE, ripple: ripple });
    }, []);
    return { state: state, create: create, release: release, entered: entered, remove: remove, cancel: cancel };
}
//# sourceMappingURL=reducer.js.map