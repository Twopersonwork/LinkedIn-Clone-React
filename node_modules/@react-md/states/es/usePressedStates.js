var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import { useCallback, useState } from "react";
import { useRefCache } from "@react-md/utils";
import { isBubbled } from "./ripples/utils";
/**
 * This is a different version of the useRippleStates that will allow you to
 * know when a component is being pressed by the user. This is really just a
 * fallback for when the ripples are disabled.
 *
 * This will return an object containing the current pressed state of the
 * element as well as all the merged eventHandlers required to trigger the
 * different states.
 *
 * NOTE: Unlike the ripple effect, this pressed states will not be triggered
 * from a programmatic click event.
 */
export function usePressedStates(_a) {
    var _b = _a === void 0 ? {} : _a, _c = _b.handlers, handlers = _c === void 0 ? {} : _c, _d = _b.disableSpacebarClick, disableSpacebarClick = _d === void 0 ? false : _d;
    var _e = useState(false), pressed = _e[0], setPressed = _e[1];
    var ref = useRefCache(__assign(__assign({}, handlers), { pressed: pressed }));
    var handleKeyDown = useCallback(function (event) {
        var _a = ref.current, onKeyDown = _a.onKeyDown, pressed = _a.pressed;
        if (onKeyDown) {
            onKeyDown(event);
        }
        var key = event.key;
        if (!pressed &&
            (key === "Enter" || (!disableSpacebarClick && key === " "))) {
            setPressed(true);
        }
    }, 
    // disabled since useRefCache for ref
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [disableSpacebarClick]);
    var handleKeyUp = useCallback(function (event) {
        var _a = ref.current, onKeyUp = _a.onKeyUp, pressed = _a.pressed;
        if (onKeyUp) {
            onKeyUp(event);
        }
        if (pressed) {
            setPressed(false);
        }
        // disabled since useRefCache for ref
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    var handleMouseDown = useCallback(function (event) {
        var _a = ref.current, onMouseDown = _a.onMouseDown, pressed = _a.pressed;
        if (onMouseDown) {
            onMouseDown(event);
        }
        if (!pressed && event.button === 0 && !isBubbled(event)) {
            setPressed(true);
        }
        // disabled since useRefCache for ref
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    var handleMouseUp = useCallback(function (event) {
        var _a = ref.current, onMouseUp = _a.onMouseUp, pressed = _a.pressed;
        if (onMouseUp) {
            onMouseUp(event);
        }
        if (pressed) {
            setPressed(false);
        }
        // disabled since useRefCache for ref
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    var handleMouseLeave = useCallback(function (event) {
        var _a = ref.current, onMouseLeave = _a.onMouseLeave, pressed = _a.pressed;
        if (onMouseLeave) {
            onMouseLeave(event);
        }
        if (pressed) {
            setPressed(false);
        }
        // disabled since useRefCache for ref
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    var handleTouchStart = useCallback(function (event) {
        var _a = ref.current, onTouchStart = _a.onTouchStart, pressed = _a.pressed;
        if (onTouchStart) {
            onTouchStart(event);
        }
        if (!pressed && !isBubbled(event)) {
            setPressed(true);
        }
        // disabled since useRefCache for ref
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    var handleTouchMove = useCallback(function (event) {
        var _a = ref.current, onTouchMove = _a.onTouchMove, pressed = _a.pressed;
        if (onTouchMove) {
            onTouchMove(event);
        }
        if (pressed) {
            setPressed(false);
        }
        // disabled since useRefCache for ref
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    var handleTouchEnd = useCallback(function (event) {
        var _a = ref.current, onTouchEnd = _a.onTouchEnd, pressed = _a.pressed;
        if (onTouchEnd) {
            onTouchEnd(event);
        }
        if (pressed) {
            setPressed(false);
        }
        // disabled since useRefCache for ref
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    return {
        pressed: pressed,
        handlers: {
            onClick: handlers.onClick,
            onKeyDown: handleKeyDown,
            onKeyUp: handleKeyUp,
            onMouseDown: handleMouseDown,
            onMouseUp: handleMouseUp,
            onMouseLeave: handleMouseLeave,
            onTouchStart: handleTouchStart,
            onTouchMove: handleTouchMove,
            onTouchEnd: handleTouchEnd,
        },
    };
}
//# sourceMappingURL=usePressedStates.js.map