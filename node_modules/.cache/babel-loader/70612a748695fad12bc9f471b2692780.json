{"ast":null,"code":"import { findSizingContainer } from \"@react-md/utils\";\n/**\n * Checks if the ripple event should be ignored since it was bubbled\n * up from a child treeitem. I should find a better way to handle\n * this at some point.\n */\n\nexport function isBubbled(event) {\n  return Array.from(event.currentTarget.querySelectorAll('[role=\"treeitem\"]')).some(function (item) {\n    return item.contains(event.target);\n  });\n}\n/**\n * Gets the ripple event type based on the provided event.\n */\n\nexport function getType(event) {\n  switch (event.type) {\n    case \"mousedown\":\n    case \"mouseup\":\n    case \"mouseleave\":\n      return \"mouse\";\n\n    case \"touchstart\":\n    case \"touchmove\":\n    case \"touchend\":\n      return \"touch\";\n\n    case \"keydown\":\n    case \"keyup\":\n      return \"keyboard\";\n\n    default:\n      return \"programmatic\";\n  }\n}\n/**\n * Checks if the provided event type is actually rippleable by ensuring:\n * - it is a mousedown event while not in touch mode and the left mouse was\n *   clicked.\n * - it was a keydown event for either tab or space when spacebar clicks have not\n *   been disabled\n * - it was a touchstart event\n */\n\nexport function isRippleable(event, disableSpacebarClick) {\n  switch (event.type) {\n    case \"mousedown\":\n      return document.querySelector(\".rmd-states--touch\") === null && event.button === 0;\n\n    case \"keydown\":\n      return !disableSpacebarClick && event.key === \" \" || event.key === \"Enter\" && !/checkbox|radio/i.test(event.currentTarget.getAttribute(\"type\") || \"\");\n\n    case \"touchstart\":\n    case \"click\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction calcHypotenuse(a, b) {\n  return Math.sqrt(a * a + b * b);\n}\n/**\n * Gets the current radius for a ripple based on the x and y page dimensions\n * as well as the size of the element.\n *\n * This is really just in a separate file so I can easily mock this and write\n * tests.\n */\n\n\nfunction getRadius(x, y, offsetWidth, offsetHeight) {\n  return Math.max(calcHypotenuse(x, y), calcHypotenuse(offsetWidth - x, y), calcHypotenuse(offsetWidth - x, offsetHeight - y), calcHypotenuse(x, offsetHeight - y));\n}\n/**\n * Gets the ripple creation origin base on the provided event. When the event\n * type is for keyboards or triggered programmatically, the origin will\n * be the center of the target element. When the event is for touch or mouse,\n * the origin will be the location within the viewport where the user touched\n * or clicked the target element.\n */\n\n\nexport function getOrigin(event, element) {\n  var _a;\n\n  var type = getType(event);\n  var offsetWidth = element.offsetWidth,\n      offsetHeight = element.offsetHeight;\n  var x;\n  var y;\n\n  if (type === \"programmatic\" || type === \"keyboard\") {\n    x = offsetWidth / 2;\n    y = offsetHeight / 2;\n  } else {\n    // if the event type is not programmatic, want to figure out exactly where in\n    // the element to trigger the animation from. this can be determined by:\n    // - getting the pageX and pageY of the mouse or touch event\n    // - getting element's current position in the page\n    var pageX = void 0;\n    var pageY = void 0;\n\n    if (type === \"mouse\") {\n      _a = event, pageX = _a.pageX, pageY = _a.pageY;\n    } else {\n      var touch = event.touches.item(0);\n      pageX = touch.pageX, pageY = touch.pageY;\n    }\n\n    var rect = element.getBoundingClientRect(); // have to include the current page's scroll offset to the element's\n    // bounding rect since the pageX and pageY from Events include the scroll\n    // offset while the bounding rect is only based on viewport.\n\n    x = pageX - (rect.left + window.pageXOffset);\n    y = pageY - (rect.top + window.pageYOffset);\n  }\n\n  return {\n    x: x,\n    y: y\n  };\n}\n/**\n * Creates a new ripple state based off the provided event type.\n */\n\nexport function createRippleState(event) {\n  var element = findSizingContainer(event.currentTarget) || event.currentTarget;\n  var offsetWidth = element.offsetWidth,\n      offsetHeight = element.offsetHeight;\n  var type = getType(event);\n\n  var _a = getOrigin(event, element),\n      x = _a.x,\n      y = _a.y;\n\n  var radius = getRadius(x, y, offsetWidth, offsetHeight);\n  var size = radius * 2;\n  return {\n    startTime: Date.now(),\n    style: {\n      left: x - radius,\n      top: y - radius,\n      height: size,\n      width: size\n    },\n    type: type,\n    holding: type !== \"programmatic\",\n    exiting: false,\n    entered: false\n  };\n}","map":{"version":3,"sources":["../../src/ripples/utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { findSizingContainer } from \"@react-md/utils\";\n/**\n * Checks if the ripple event should be ignored since it was bubbled\n * up from a child treeitem. I should find a better way to handle\n * this at some point.\n */\nexport function isBubbled(event) {\n    return Array.from(event.currentTarget.querySelectorAll('[role=\"treeitem\"]')).some(function (item) { return item.contains(event.target); });\n}\n/**\n * Gets the ripple event type based on the provided event.\n */\nexport function getType(event) {\n    switch (event.type) {\n        case \"mousedown\":\n        case \"mouseup\":\n        case \"mouseleave\":\n            return \"mouse\";\n        case \"touchstart\":\n        case \"touchmove\":\n        case \"touchend\":\n            return \"touch\";\n        case \"keydown\":\n        case \"keyup\":\n            return \"keyboard\";\n        default:\n            return \"programmatic\";\n    }\n}\n/**\n * Checks if the provided event type is actually rippleable by ensuring:\n * - it is a mousedown event while not in touch mode and the left mouse was\n *   clicked.\n * - it was a keydown event for either tab or space when spacebar clicks have not\n *   been disabled\n * - it was a touchstart event\n */\nexport function isRippleable(event, disableSpacebarClick) {\n    switch (event.type) {\n        case \"mousedown\":\n            return (document.querySelector(\".rmd-states--touch\") === null &&\n                event.button === 0);\n        case \"keydown\":\n            return ((!disableSpacebarClick && event.key === \" \") ||\n                (event.key === \"Enter\" &&\n                    !/checkbox|radio/i.test(event.currentTarget.getAttribute(\"type\") || \"\")));\n        case \"touchstart\":\n        case \"click\":\n            return true;\n        default:\n            return false;\n    }\n}\nfunction calcHypotenuse(a, b) {\n    return Math.sqrt(a * a + b * b);\n}\n/**\n * Gets the current radius for a ripple based on the x and y page dimensions\n * as well as the size of the element.\n *\n * This is really just in a separate file so I can easily mock this and write\n * tests.\n */\nfunction getRadius(x, y, offsetWidth, offsetHeight) {\n    return Math.max(calcHypotenuse(x, y), calcHypotenuse(offsetWidth - x, y), calcHypotenuse(offsetWidth - x, offsetHeight - y), calcHypotenuse(x, offsetHeight - y));\n}\n/**\n * Gets the ripple creation origin base on the provided event. When the event\n * type is for keyboards or triggered programmatically, the origin will\n * be the center of the target element. When the event is for touch or mouse,\n * the origin will be the location within the viewport where the user touched\n * or clicked the target element.\n */\nexport function getOrigin(event, element) {\n    var _a;\n    var type = getType(event);\n    var offsetWidth = element.offsetWidth, offsetHeight = element.offsetHeight;\n    var x;\n    var y;\n    if (type === \"programmatic\" || type === \"keyboard\") {\n        x = offsetWidth / 2;\n        y = offsetHeight / 2;\n    }\n    else {\n        // if the event type is not programmatic, want to figure out exactly where in\n        // the element to trigger the animation from. this can be determined by:\n        // - getting the pageX and pageY of the mouse or touch event\n        // - getting element's current position in the page\n        var pageX = void 0;\n        var pageY = void 0;\n        if (type === \"mouse\") {\n            (_a = event, pageX = _a.pageX, pageY = _a.pageY);\n        }\n        else {\n            var touch = event.touches.item(0);\n            (pageX = touch.pageX, pageY = touch.pageY);\n        }\n        var rect = element.getBoundingClientRect();\n        // have to include the current page's scroll offset to the element's\n        // bounding rect since the pageX and pageY from Events include the scroll\n        // offset while the bounding rect is only based on viewport.\n        x = pageX - (rect.left + window.pageXOffset);\n        y = pageY - (rect.top + window.pageYOffset);\n    }\n    return { x: x, y: y };\n}\n/**\n * Creates a new ripple state based off the provided event type.\n */\nexport function createRippleState(event) {\n    var element = findSizingContainer(event.currentTarget) || event.currentTarget;\n    var offsetWidth = element.offsetWidth, offsetHeight = element.offsetHeight;\n    var type = getType(event);\n    var _a = getOrigin(event, element), x = _a.x, y = _a.y;\n    var radius = getRadius(x, y, offsetWidth, offsetHeight);\n    var size = radius * 2;\n    return {\n        startTime: Date.now(),\n        style: {\n            left: x - radius,\n            top: y - radius,\n            height: size,\n            width: size,\n        },\n        type: type,\n        holding: type !== \"programmatic\",\n        exiting: false,\n        entered: false,\n    };\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}