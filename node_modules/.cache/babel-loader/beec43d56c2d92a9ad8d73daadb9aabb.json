{"ast":null,"code":"import { scrollIntoView } from \"../scrollIntoView\";\nimport { getFocusableElements } from \"./getFocusableElements\";\nimport { isFocusable } from \"./isFocusable\";\n/**\n * A function that is used to focus an element within the provided node.  This\n * can either focus the first, last, or a querySelector found element.\n *\n * @param container - Either an HTMLElement or the document to focus an element\n * within.\n * @param focus - Either the \"first\" or \"last\" string to focus the first or last\n * focusable element within the container or a query selector string to find a\n * focusable element within the container.\n * @param programmatic - Boolean if programmatically focusable elements should be\n * included as well.\n * @param preventScroll - Boolean if the focus event should not scroll the\n * element into view. This should normally remain `false`, but can be useful if\n * the element gets focused while offscreen during a transition.\n * @param elements - Optonal child elements to search\n * @remarks \\@since 2.8.0 Supports focusing the container element if it is\n * focusable\n */\n\nexport function focusElementWithin(container, focus, programmatic, preventScroll, elements) {\n  if (programmatic === void 0) {\n    programmatic = false;\n  }\n\n  if (preventScroll === void 0) {\n    preventScroll = false;\n  }\n\n  if (!elements || !elements.length) {\n    elements = getFocusableElements(container, programmatic);\n  }\n\n  var el;\n\n  switch (focus) {\n    case \"first\":\n      el = elements[0];\n      break;\n\n    case \"last\":\n      el = elements[elements.length - 1];\n      break;\n\n    default:\n      el = container.querySelector(focus);\n  } // just allow any focusable-type element\n\n\n  if (!el && isFocusable(container, \"programmatic\")) {\n    el = container;\n  }\n\n  if (!el) {\n    throw new Error(\"Unable to find a focusable element\");\n  }\n\n  el.focus({\n    preventScroll: preventScroll\n  });\n\n  if (!preventScroll && container !== document) {\n    scrollIntoView(container, el);\n  }\n}","map":{"version":3,"sources":["../../src/wia-aria/focusElementWithin.ts"],"names":[],"mappings":"AAAA,SAAS,cAAT,QAA+B,mBAA/B;AACA,SAAS,oBAAT,QAAqC,wBAArC;AACA,SAAS,WAAT,QAA4B,eAA5B;AAIA;;;;;;;;;;;;;;;;;AAiBG;;AACH,OAAM,SAAU,kBAAV,CACJ,SADI,EAEJ,KAFI,EAGJ,YAHI,EAIJ,aAJI,EAKJ,QALI,EAKoB;AAFxB,MAAA,YAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,YAAA,GAAA,KAAA;AAAoB;;AACpB,MAAA,aAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,aAAA,GAAA,KAAA;AAAqB;;AAGrB,MAAI,CAAC,QAAD,IAAa,CAAC,QAAQ,CAAC,MAA3B,EAAmC;AACjC,IAAA,QAAQ,GAAG,oBAAoB,CAAC,SAAD,EAAY,YAAZ,CAA/B;AACD;;AAED,MAAI,EAAJ;;AACA,UAAQ,KAAR;AACE,SAAK,OAAL;AACG,MAAA,EAAE,GAAI,QAAQ,CAAZ,CAAY,CAAd;AACD;;AACF,SAAK,MAAL;AACE,MAAA,EAAE,GAAG,QAAQ,CAAC,QAAQ,CAAC,MAAT,GAAkB,CAAnB,CAAb;AACA;;AACF;AACE,MAAA,EAAE,GAAG,SAAS,CAAC,aAAV,CAAqC,KAArC,CAAL;AARJ,GAPwB,CAkBxB;;;AACA,MAAI,CAAC,EAAD,IAAO,WAAW,CAAC,SAAD,EAAY,cAAZ,CAAtB,EAAmD;AACjD,IAAA,EAAE,GAAG,SAAL;AACD;;AAED,MAAI,CAAC,EAAL,EAAS;AACP,UAAM,IAAI,KAAJ,CAAU,oCAAV,CAAN;AACD;;AAED,EAAA,EAAE,CAAC,KAAH,CAAS;AAAE,IAAA,aAAa,EAAA;AAAf,GAAT;;AACA,MAAI,CAAC,aAAD,IAAkB,SAAS,KAAK,QAApC,EAA8C;AAC5C,IAAA,cAAc,CAAC,SAAD,EAA2B,EAA3B,CAAd;AACD;AACF","sourceRoot":"","sourcesContent":["import { scrollIntoView } from \"../scrollIntoView\";\nimport { getFocusableElements } from \"./getFocusableElements\";\nimport { isFocusable } from \"./isFocusable\";\n/**\n * A function that is used to focus an element within the provided node.  This\n * can either focus the first, last, or a querySelector found element.\n *\n * @param container - Either an HTMLElement or the document to focus an element\n * within.\n * @param focus - Either the \"first\" or \"last\" string to focus the first or last\n * focusable element within the container or a query selector string to find a\n * focusable element within the container.\n * @param programmatic - Boolean if programmatically focusable elements should be\n * included as well.\n * @param preventScroll - Boolean if the focus event should not scroll the\n * element into view. This should normally remain `false`, but can be useful if\n * the element gets focused while offscreen during a transition.\n * @param elements - Optonal child elements to search\n * @remarks \\@since 2.8.0 Supports focusing the container element if it is\n * focusable\n */\nexport function focusElementWithin(container, focus, programmatic, preventScroll, elements) {\n    if (programmatic === void 0) { programmatic = false; }\n    if (preventScroll === void 0) { preventScroll = false; }\n    if (!elements || !elements.length) {\n        elements = getFocusableElements(container, programmatic);\n    }\n    var el;\n    switch (focus) {\n        case \"first\":\n            el = elements[0];\n            break;\n        case \"last\":\n            el = elements[elements.length - 1];\n            break;\n        default:\n            el = container.querySelector(focus);\n    }\n    // just allow any focusable-type element\n    if (!el && isFocusable(container, \"programmatic\")) {\n        el = container;\n    }\n    if (!el) {\n        throw new Error(\"Unable to find a focusable element\");\n    }\n    el.focus({ preventScroll: preventScroll });\n    if (!preventScroll && container !== document) {\n        scrollIntoView(container, el);\n    }\n}\n//# sourceMappingURL=focusElementWithin.js.map"]},"metadata":{},"sourceType":"module"}