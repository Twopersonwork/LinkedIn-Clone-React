{"ast":null,"code":"import { getCenterXCoord, getInnerLeftCoord, getInnerRightCoord, getLeftCoord, getRightCoord } from \"./getCoord\";\n/**\n * Attempts to position the fixed element so that it will appear to the left of\n * the container element but also within the viewport boundaries. When swapping\n * is enabled, it will attempt to swap to the right position if it can't fit\n * within the viewport to the left. If it can't fit in the viewport even after\n * being swapped to the right or swapping is disabled, it will be positioned to\n * the viewport left boundary.\n *\n * @internal\n */\n\nexport function createAnchoredLeft(config) {\n  var vwMargin = config.vwMargin,\n      screenRight = config.screenRight,\n      elWidth = config.elWidth,\n      disableSwapping = config.disableSwapping;\n  var left = getLeftCoord(config);\n  var actualX = \"left\";\n\n  if (left >= vwMargin) {\n    return {\n      actualX: actualX,\n      left: left\n    };\n  }\n\n  var swappedLeft = getRightCoord(config);\n\n  if (disableSwapping || swappedLeft + elWidth > screenRight) {\n    left = vwMargin;\n  } else {\n    left = swappedLeft;\n    actualX = \"right\";\n  }\n\n  return {\n    actualX: actualX,\n    left: left\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear to the\n * inner-left of the container element but also within the viewport boundaries.\n * When swapping is enabled, it will attempt to swap to the right position if it\n * can't fit within the viewport to the left. If it can't fit in the viewport\n * even after being swapped to the right or swapping is disabled, it will be\n * positioned to the viewport left boundary.\n *\n * @internal\n */\n\nexport function createAnchoredInnerLeft(config) {\n  var vwMargin = config.vwMargin,\n      screenRight = config.screenRight,\n      elWidth = config.elWidth,\n      disableSwapping = config.disableSwapping;\n  var left = getInnerLeftCoord(config);\n  var actualX = \"inner-left\";\n\n  if (left + elWidth <= screenRight) {\n    return {\n      actualX: actualX,\n      left: left\n    };\n  }\n\n  var swappedLeft = getInnerRightCoord(config);\n\n  if (disableSwapping || swappedLeft < vwMargin) {\n    left = vwMargin;\n  } else {\n    left = swappedLeft;\n    actualX = \"inner-right\";\n  }\n\n  return {\n    actualX: actualX,\n    left: left\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear at the center\n * of the container element but also within the viewport boundaries. If the\n * centered element can't fit within the viewport, it will use the vwMargin\n * value if it overflowed to the left, it'll position to the screen right\n * boundary.\n *\n * @internal\n */\n\nexport function createAnchoredCenter(config) {\n  var vwMargin = config.vwMargin,\n      screenRight = config.screenRight,\n      elWidth = config.elWidth;\n  var left = getCenterXCoord(config);\n\n  if (left < vwMargin) {\n    left = vwMargin;\n  } else if (left + elWidth > screenRight || left < vwMargin) {\n    left = screenRight - elWidth;\n  }\n\n  return {\n    actualX: \"center\",\n    left: left\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear to the\n * inner-right of the container element but also within the viewport boundaries.\n * When swapping is enabled, it will attempt to swap to the inner-left position\n * if it can't fit within the viewport to the right. If it can't fit in the\n * viewport even after being swapped to the left or swapping is disabled, it\n * will be positioned to the viewport right boundary.\n *\n * @internal\n */\n\nexport function createAnchoredInnerRight(config) {\n  var screenRight = config.screenRight,\n      vwMargin = config.vwMargin,\n      elWidth = config.elWidth,\n      disableSwapping = config.disableSwapping;\n  var left = getInnerRightCoord(config);\n  var actualX = \"inner-right\";\n\n  if (left >= vwMargin) {\n    return {\n      actualX: actualX,\n      left: left\n    };\n  }\n\n  var swappedLeft = getInnerLeftCoord(config);\n\n  if (disableSwapping || swappedLeft + elWidth > screenRight) {\n    left = screenRight - elWidth;\n  } else {\n    left = swappedLeft;\n    actualX = \"inner-left\";\n  }\n\n  return {\n    actualX: actualX,\n    left: left\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear to the right of\n * the container element but also within the viewport boundaries. When swapping\n * is enabled, it will attempt to swap to the left position if it can't fit\n * within the viewport to the right. If it can't fit in the viewport even after\n * being swapped to the left or swapping is disabled, it will be positioned to\n * the viewport right boundary.\n *\n * @internal\n */\n\nexport function createAnchoredRight(config) {\n  var screenRight = config.screenRight,\n      vwMargin = config.vwMargin,\n      elWidth = config.elWidth,\n      disableSwapping = config.disableSwapping;\n  var left = getRightCoord(config);\n  var actualX = \"right\";\n\n  if (left + elWidth <= screenRight) {\n    return {\n      actualX: actualX,\n      left: left\n    };\n  }\n\n  var swappedLeft = getLeftCoord(config);\n\n  if (disableSwapping || swappedLeft < vwMargin) {\n    left = screenRight - elWidth;\n  } else {\n    left = swappedLeft;\n    actualX = \"left\";\n  }\n\n  return {\n    actualX: actualX,\n    left: left\n  };\n}\n/**\n * @internal\n */\n\nexport function createEqualWidth(_a) {\n  var x = _a.x,\n      vw = _a.vw,\n      elWidth = _a.elWidth,\n      xMargin = _a.xMargin,\n      vwMargin = _a.vwMargin,\n      initialX = _a.initialX,\n      containerRect = _a.containerRect,\n      isMinWidth = _a.isMinWidth;\n  var left = initialX !== null && initialX !== void 0 ? initialX : containerRect.left + xMargin;\n  var width = containerRect.width - xMargin * 2;\n  var minWidth;\n  var right;\n\n  if (isMinWidth) {\n    minWidth = width;\n    width = undefined;\n\n    if (left + elWidth > vw - vwMargin) {\n      right = vwMargin;\n    }\n  } // going to assume that the container element is visible in the DOM and just\n  // make the fixed element have the same left and right corners\n\n\n  return {\n    left: left,\n    right: right,\n    width: width,\n    minWidth: minWidth,\n    actualX: x\n  };\n}\n/**\n * Creates the horizontal position for a fixed element with the provided\n * options.\n * @internal\n */\n\nexport function createHorizontalPosition(_a) {\n  var x = _a.x,\n      vw = _a.vw,\n      vwMargin = _a.vwMargin,\n      xMargin = _a.xMargin,\n      width = _a.width,\n      elWidth = _a.elWidth,\n      initialX = _a.initialX,\n      containerRect = _a.containerRect,\n      disableSwapping = _a.disableSwapping;\n\n  if (width === \"min\" || width === \"equal\") {\n    return createEqualWidth({\n      x: x,\n      vw: vw,\n      vwMargin: vwMargin,\n      xMargin: xMargin,\n      elWidth: elWidth,\n      initialX: initialX,\n      containerRect: containerRect,\n      isMinWidth: width === \"min\"\n    });\n  }\n\n  if (elWidth > vw - vwMargin * 2) {\n    // if the element's width is greater than the viewport's width minus the\n    // margin on both sides, just make the element span the entire viewport with\n    // the margin\n    return {\n      left: vwMargin,\n      right: vwMargin,\n      actualX: x\n    };\n  }\n\n  var config = {\n    vwMargin: vwMargin,\n    xMargin: xMargin,\n    elWidth: elWidth,\n    initialX: initialX,\n    screenRight: vw - vwMargin,\n    containerRect: containerRect,\n    disableSwapping: disableSwapping\n  };\n\n  switch (x) {\n    case \"left\":\n      return createAnchoredLeft(config);\n\n    case \"inner-left\":\n      return createAnchoredInnerLeft(config);\n\n    case \"center\":\n      return createAnchoredCenter(config);\n\n    case \"inner-right\":\n      return createAnchoredInnerRight(config);\n\n    case \"right\":\n      return createAnchoredRight(config);\n\n    default:\n      throw new Error(\"This should never happen\");\n  }\n}","map":{"version":3,"sources":["../../src/positioning/createHorizontalPosition.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getCenterXCoord, getInnerLeftCoord, getInnerRightCoord, getLeftCoord, getRightCoord, } from \"./getCoord\";\n/**\n * Attempts to position the fixed element so that it will appear to the left of\n * the container element but also within the viewport boundaries. When swapping\n * is enabled, it will attempt to swap to the right position if it can't fit\n * within the viewport to the left. If it can't fit in the viewport even after\n * being swapped to the right or swapping is disabled, it will be positioned to\n * the viewport left boundary.\n *\n * @internal\n */\nexport function createAnchoredLeft(config) {\n    var vwMargin = config.vwMargin, screenRight = config.screenRight, elWidth = config.elWidth, disableSwapping = config.disableSwapping;\n    var left = getLeftCoord(config);\n    var actualX = \"left\";\n    if (left >= vwMargin) {\n        return { actualX: actualX, left: left };\n    }\n    var swappedLeft = getRightCoord(config);\n    if (disableSwapping || swappedLeft + elWidth > screenRight) {\n        left = vwMargin;\n    }\n    else {\n        left = swappedLeft;\n        actualX = \"right\";\n    }\n    return { actualX: actualX, left: left };\n}\n/**\n * Attempts to position the fixed element so that it will appear to the\n * inner-left of the container element but also within the viewport boundaries.\n * When swapping is enabled, it will attempt to swap to the right position if it\n * can't fit within the viewport to the left. If it can't fit in the viewport\n * even after being swapped to the right or swapping is disabled, it will be\n * positioned to the viewport left boundary.\n *\n * @internal\n */\nexport function createAnchoredInnerLeft(config) {\n    var vwMargin = config.vwMargin, screenRight = config.screenRight, elWidth = config.elWidth, disableSwapping = config.disableSwapping;\n    var left = getInnerLeftCoord(config);\n    var actualX = \"inner-left\";\n    if (left + elWidth <= screenRight) {\n        return { actualX: actualX, left: left };\n    }\n    var swappedLeft = getInnerRightCoord(config);\n    if (disableSwapping || swappedLeft < vwMargin) {\n        left = vwMargin;\n    }\n    else {\n        left = swappedLeft;\n        actualX = \"inner-right\";\n    }\n    return { actualX: actualX, left: left };\n}\n/**\n * Attempts to position the fixed element so that it will appear at the center\n * of the container element but also within the viewport boundaries. If the\n * centered element can't fit within the viewport, it will use the vwMargin\n * value if it overflowed to the left, it'll position to the screen right\n * boundary.\n *\n * @internal\n */\nexport function createAnchoredCenter(config) {\n    var vwMargin = config.vwMargin, screenRight = config.screenRight, elWidth = config.elWidth;\n    var left = getCenterXCoord(config);\n    if (left < vwMargin) {\n        left = vwMargin;\n    }\n    else if (left + elWidth > screenRight || left < vwMargin) {\n        left = screenRight - elWidth;\n    }\n    return { actualX: \"center\", left: left };\n}\n/**\n * Attempts to position the fixed element so that it will appear to the\n * inner-right of the container element but also within the viewport boundaries.\n * When swapping is enabled, it will attempt to swap to the inner-left position\n * if it can't fit within the viewport to the right. If it can't fit in the\n * viewport even after being swapped to the left or swapping is disabled, it\n * will be positioned to the viewport right boundary.\n *\n * @internal\n */\nexport function createAnchoredInnerRight(config) {\n    var screenRight = config.screenRight, vwMargin = config.vwMargin, elWidth = config.elWidth, disableSwapping = config.disableSwapping;\n    var left = getInnerRightCoord(config);\n    var actualX = \"inner-right\";\n    if (left >= vwMargin) {\n        return { actualX: actualX, left: left };\n    }\n    var swappedLeft = getInnerLeftCoord(config);\n    if (disableSwapping || swappedLeft + elWidth > screenRight) {\n        left = screenRight - elWidth;\n    }\n    else {\n        left = swappedLeft;\n        actualX = \"inner-left\";\n    }\n    return { actualX: actualX, left: left };\n}\n/**\n * Attempts to position the fixed element so that it will appear to the right of\n * the container element but also within the viewport boundaries. When swapping\n * is enabled, it will attempt to swap to the left position if it can't fit\n * within the viewport to the right. If it can't fit in the viewport even after\n * being swapped to the left or swapping is disabled, it will be positioned to\n * the viewport right boundary.\n *\n * @internal\n */\nexport function createAnchoredRight(config) {\n    var screenRight = config.screenRight, vwMargin = config.vwMargin, elWidth = config.elWidth, disableSwapping = config.disableSwapping;\n    var left = getRightCoord(config);\n    var actualX = \"right\";\n    if (left + elWidth <= screenRight) {\n        return { actualX: actualX, left: left };\n    }\n    var swappedLeft = getLeftCoord(config);\n    if (disableSwapping || swappedLeft < vwMargin) {\n        left = screenRight - elWidth;\n    }\n    else {\n        left = swappedLeft;\n        actualX = \"left\";\n    }\n    return { actualX: actualX, left: left };\n}\n/**\n * @internal\n */\nexport function createEqualWidth(_a) {\n    var x = _a.x, vw = _a.vw, elWidth = _a.elWidth, xMargin = _a.xMargin, vwMargin = _a.vwMargin, initialX = _a.initialX, containerRect = _a.containerRect, isMinWidth = _a.isMinWidth;\n    var left = initialX !== null && initialX !== void 0 ? initialX : containerRect.left + xMargin;\n    var width = containerRect.width - xMargin * 2;\n    var minWidth;\n    var right;\n    if (isMinWidth) {\n        minWidth = width;\n        width = undefined;\n        if (left + elWidth > vw - vwMargin) {\n            right = vwMargin;\n        }\n    }\n    // going to assume that the container element is visible in the DOM and just\n    // make the fixed element have the same left and right corners\n    return {\n        left: left,\n        right: right,\n        width: width,\n        minWidth: minWidth,\n        actualX: x,\n    };\n}\n/**\n * Creates the horizontal position for a fixed element with the provided\n * options.\n * @internal\n */\nexport function createHorizontalPosition(_a) {\n    var x = _a.x, vw = _a.vw, vwMargin = _a.vwMargin, xMargin = _a.xMargin, width = _a.width, elWidth = _a.elWidth, initialX = _a.initialX, containerRect = _a.containerRect, disableSwapping = _a.disableSwapping;\n    if (width === \"min\" || width === \"equal\") {\n        return createEqualWidth({\n            x: x,\n            vw: vw,\n            vwMargin: vwMargin,\n            xMargin: xMargin,\n            elWidth: elWidth,\n            initialX: initialX,\n            containerRect: containerRect,\n            isMinWidth: width === \"min\",\n        });\n    }\n    if (elWidth > vw - vwMargin * 2) {\n        // if the element's width is greater than the viewport's width minus the\n        // margin on both sides, just make the element span the entire viewport with\n        // the margin\n        return {\n            left: vwMargin,\n            right: vwMargin,\n            actualX: x,\n        };\n    }\n    var config = {\n        vwMargin: vwMargin,\n        xMargin: xMargin,\n        elWidth: elWidth,\n        initialX: initialX,\n        screenRight: vw - vwMargin,\n        containerRect: containerRect,\n        disableSwapping: disableSwapping,\n    };\n    switch (x) {\n        case \"left\":\n            return createAnchoredLeft(config);\n        case \"inner-left\":\n            return createAnchoredInnerLeft(config);\n        case \"center\":\n            return createAnchoredCenter(config);\n        case \"inner-right\":\n            return createAnchoredInnerRight(config);\n        case \"right\":\n            return createAnchoredRight(config);\n        default:\n            throw new Error(\"This should never happen\");\n    }\n}\n//# sourceMappingURL=createHorizontalPosition.js.map"]},"metadata":{},"sourceType":"module"}