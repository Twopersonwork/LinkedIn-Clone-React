{"ast":null,"code":"import { useEffect, useRef } from \"react\";\n/**\n * This hook is used to focus the previous element when a component unmounts.\n * The default behavior is to store the current activeElement within the\n * document when the component mounts and then try to focus it again when the\n * component unmounts.  You can also provide your own HTMLElement to focus when\n * unmounting.\n *\n * During the unmount phase, it will wait for an animation frame before checking\n * if the fallback element still exists within the page. If it doesn't, it will\n * use the fallback query/element/function to attempt to find another element to\n * focus. If the element exists within the page, it will then finally be\n * focused.\n *\n * The animation frame is unfortunately required for keyboard users as pressing\n * enter key will click the previous element immediately on focus as well.\n *\n * @param disabled - Boolean if the focus behavior should be disabled.\n * @param fallback - The fallback query, element, or function to use if the\n * previous element no longer exists in the DOM.\n * @param previousElement - An optional previous element to focus. If this is\n * omitted, the `document.activeElement` will be used instead.\n */\n\nexport function usePreviousFocus(disabled, fallback, previousElement) {\n  if (fallback === void 0) {\n    fallback = undefined;\n  }\n\n  if (previousElement === void 0) {\n    previousElement = null;\n  }\n\n  var options = useRef({\n    disabled: disabled,\n    fallback: fallback\n  });\n  useEffect(function () {\n    options.current = {\n      disabled: disabled,\n      fallback: fallback\n    };\n  });\n  useEffect(function () {\n    if (disabled) {\n      return;\n    }\n\n    var element = previousElement || document.activeElement; // i'll need to think of a better way to handle this flow. There's just a\n    // weird one where if going from a menu to a dialog, we get lost without\n    // specifying a fallback. So if we are in a menu, try to find the\n    // corresponding menu button for this flow to fallback to.\n\n    var menu = element.closest('[role=\"menu\"]');\n    var menuButton = null;\n\n    if (menu) {\n      // first try to get the button by using the menu's id minus the trailing\n      // -menu since that's the normal pattern within react-md.\n      menuButton = document.getElementById(menu.id.replace(/-menu$/, \"\"));\n\n      if (!menuButton) {\n        // if no menu button, try to see if the `aria-labelledby` points to the\n        // button... but since the `aria-labelledby` is a space-deliminated\n        // string of ids, have to check each one\n        var labelledBy = menu.getAttribute(\"aria-labelledby\") || \"\";\n        var query = labelledBy.split(\" \").map(function (id) {\n          return \"#\" + id + \"[tabindex]\";\n        }).join(\",\");\n        menuButton = query ? document.querySelector(query) : null;\n      }\n    }\n\n    return function () {\n      var _a = options.current,\n          fallback = _a.fallback,\n          disabled = _a.disabled;\n\n      if (disabled) {\n        // this has been added just for support for scrolling menus out of view.\n        // It is not ideal since keyboard focus is lost at this point, but\n        // _technically_ shouldn't be able to reach this flow with keyboard\n        // movement\n        return;\n      }\n\n      if (menu && menuButton && !previousElement && !fallback && !document.contains(element) && document.contains(menuButton)) {\n        menuButton.focus();\n        return;\n      }\n\n      var el = element;\n\n      if (!document.contains(el)) {\n        el = previousElement && document.contains(previousElement) ? previousElement : null;\n      }\n\n      if (!el && fallback) {\n        switch (typeof fallback) {\n          case \"string\":\n            el = document.querySelector(fallback);\n            break;\n\n          case \"function\":\n            el = fallback();\n            break;\n\n          default:\n            el = fallback;\n        }\n      }\n\n      if (el && !document.contains(el)) {\n        el = null;\n      }\n\n      if (el) {\n        el.focus();\n      }\n    }; // disabled since useRefCache and don't wnt to update on disabled change\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n}","map":{"version":3,"sources":["../../src/wia-aria/usePreviousFocus.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { useEffect, useRef } from \"react\";\n/**\n * This hook is used to focus the previous element when a component unmounts.\n * The default behavior is to store the current activeElement within the\n * document when the component mounts and then try to focus it again when the\n * component unmounts.  You can also provide your own HTMLElement to focus when\n * unmounting.\n *\n * During the unmount phase, it will wait for an animation frame before checking\n * if the fallback element still exists within the page. If it doesn't, it will\n * use the fallback query/element/function to attempt to find another element to\n * focus. If the element exists within the page, it will then finally be\n * focused.\n *\n * The animation frame is unfortunately required for keyboard users as pressing\n * enter key will click the previous element immediately on focus as well.\n *\n * @param disabled - Boolean if the focus behavior should be disabled.\n * @param fallback - The fallback query, element, or function to use if the\n * previous element no longer exists in the DOM.\n * @param previousElement - An optional previous element to focus. If this is\n * omitted, the `document.activeElement` will be used instead.\n */\nexport function usePreviousFocus(disabled, fallback, previousElement) {\n    if (fallback === void 0) { fallback = undefined; }\n    if (previousElement === void 0) { previousElement = null; }\n    var options = useRef({\n        disabled: disabled,\n        fallback: fallback,\n    });\n    useEffect(function () {\n        options.current = {\n            disabled: disabled,\n            fallback: fallback,\n        };\n    });\n    useEffect(function () {\n        if (disabled) {\n            return;\n        }\n        var element = previousElement || document.activeElement;\n        // i'll need to think of a better way to handle this flow. There's just a\n        // weird one where if going from a menu to a dialog, we get lost without\n        // specifying a fallback. So if we are in a menu, try to find the\n        // corresponding menu button for this flow to fallback to.\n        var menu = element.closest('[role=\"menu\"]');\n        var menuButton = null;\n        if (menu) {\n            // first try to get the button by using the menu's id minus the trailing\n            // -menu since that's the normal pattern within react-md.\n            menuButton = document.getElementById(menu.id.replace(/-menu$/, \"\"));\n            if (!menuButton) {\n                // if no menu button, try to see if the `aria-labelledby` points to the\n                // button... but since the `aria-labelledby` is a space-deliminated\n                // string of ids, have to check each one\n                var labelledBy = menu.getAttribute(\"aria-labelledby\") || \"\";\n                var query = labelledBy\n                    .split(\" \")\n                    .map(function (id) { return \"#\" + id + \"[tabindex]\"; })\n                    .join(\",\");\n                menuButton = query ? document.querySelector(query) : null;\n            }\n        }\n        return function () {\n            var _a = options.current, fallback = _a.fallback, disabled = _a.disabled;\n            if (disabled) {\n                // this has been added just for support for scrolling menus out of view.\n                // It is not ideal since keyboard focus is lost at this point, but\n                // _technically_ shouldn't be able to reach this flow with keyboard\n                // movement\n                return;\n            }\n            if (menu &&\n                menuButton &&\n                !previousElement &&\n                !fallback &&\n                !document.contains(element) &&\n                document.contains(menuButton)) {\n                menuButton.focus();\n                return;\n            }\n            var el = element;\n            if (!document.contains(el)) {\n                el =\n                    previousElement && document.contains(previousElement)\n                        ? previousElement\n                        : null;\n            }\n            if (!el && fallback) {\n                switch (typeof fallback) {\n                    case \"string\":\n                        el = document.querySelector(fallback);\n                        break;\n                    case \"function\":\n                        el = fallback();\n                        break;\n                    default:\n                        el = fallback;\n                }\n            }\n            if (el && !document.contains(el)) {\n                el = null;\n            }\n            if (el) {\n                el.focus();\n            }\n        };\n        // disabled since useRefCache and don't wnt to update on disabled change\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n}\n//# sourceMappingURL=usePreviousFocus.js.map"]},"metadata":{},"sourceType":"module"}