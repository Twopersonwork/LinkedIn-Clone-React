{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nimport { useCallback, useMemo } from \"react\";\nimport { loop } from \"../../loop\";\nimport { useKeyboardSearch } from \"../../search/useKeyboardSearch\";\nimport { DEFAULT_GET_ITEM_VALUE, DEFAULT_VALUE_KEY } from \"../../search/utils\";\nimport { getKeyboardConfig, getStringifiedKeyConfig, transformKeys } from \"./utils\";\n/**\n * This is a low-level hook for providing custom keyboard movement based on key\n * configurations.  This normally shouldn't really be used externally since\n * you'll most likely want to use the \"presets\" of `useFocusMovement` and\n * `useActiveDescendantMovement` that implement the main movement types already\n * for you.\n *\n * The way this works is that it will general a list of mutable item refs that\n * should be applied to each DOM node for the corresponding `item` within the\n * `items` list. This list will change and regenerate itself each time the\n * `items` array changes so it'll always be in-sync with the DOM nodes. This\n * means that if you have some items that **should not be rendered**, they\n * should not be included within the items list. The main reason these item refs\n * are required is so that the `aria-acativedescendant` movement can scroll the\n * new \"focused\" element into view if needed while the \"true\" focus movement can\n * trigger a `ref.current.focus()` on the new item as needed.\n *\n * Finally, this will create a keydown event handler that will merge in the\n * optionally provided `onKeyDown` prop and check if the pressed key should\n * trigger a custom keyboard movement event.  If it does, an `onChange` event\n * will be fired with the matching data and allows for custom movement with\n * `target.focus()` or updating the `aria-activedescendant` attribute as needed.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\n\nexport function useKeyboardMovement(_a) {\n  var onKeyDown = _a.onKeyDown,\n      incrementKeys = _a.incrementKeys,\n      decrementKeys = _a.decrementKeys,\n      jumpToFirstKeys = _a.jumpToFirstKeys,\n      jumpToLastKeys = _a.jumpToLastKeys,\n      _b = _a.stopPropagation,\n      stopPropagation = _b === void 0 ? true : _b,\n      onChange = _a.onChange,\n      items = _a.items,\n      resetTime = _a.resetTime,\n      findMatchIndex = _a.findMatchIndex,\n      focusedIndex = _a.focusedIndex,\n      _c = _a.loopable,\n      loopable = _c === void 0 ? true : _c,\n      _d = _a.searchable,\n      searchable = _d === void 0 ? true : _d,\n      _e = _a.valueKey,\n      valueKey = _e === void 0 ? DEFAULT_VALUE_KEY : _e,\n      _f = _a.getItemValue,\n      getItemValue = _f === void 0 ? DEFAULT_GET_ITEM_VALUE : _f;\n  var keys = useMemo(function () {\n    return __spreadArray(__spreadArray(__spreadArray(__spreadArray([], transformKeys(incrementKeys, \"increment\")), transformKeys(decrementKeys, \"decrement\")), transformKeys(jumpToFirstKeys, \"first\")), transformKeys(jumpToLastKeys, \"last\"));\n  }, [incrementKeys, decrementKeys, jumpToFirstKeys, jumpToLastKeys]);\n  var itemRefs = useMemo(function () {\n    return Array.from(items, function () {\n      return {\n        current: null\n      };\n    });\n  }, [items]);\n  var handleSearch = useKeyboardSearch({\n    items: items,\n    valueKey: valueKey,\n    getItemValue: getItemValue,\n    onChange: function (data) {\n      onChange(data, itemRefs);\n    },\n    searchIndex: focusedIndex,\n    resetTime: resetTime,\n    findMatchIndex: findMatchIndex\n  });\n  var handleKeyDown = useCallback(function (event) {\n    if (searchable) {\n      handleSearch(event);\n    }\n\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n\n    var target = event.target;\n    var keyConfig = getKeyboardConfig(event, keys);\n\n    if (!keyConfig || !target) {\n      return;\n    } // implementing custom behavior, so prevent default of scrolling or other\n    // things\n\n\n    event.preventDefault();\n\n    if (stopPropagation) {\n      event.stopPropagation();\n    }\n\n    var type = keyConfig.type;\n    var lastIndex = items.length - 1;\n    var index;\n\n    switch (type) {\n      case \"first\":\n        index = 0;\n        break;\n\n      case \"last\":\n        index = lastIndex;\n        break;\n\n      default:\n        index = loop({\n          value: focusedIndex,\n          max: lastIndex,\n          increment: type === \"increment\",\n          minmax: !loopable\n        });\n    }\n\n    if (index === focusedIndex) {\n      return;\n    }\n\n    var data = {\n      index: index,\n      item: items[index],\n      items: items,\n      query: getStringifiedKeyConfig(keyConfig),\n      target: event.currentTarget\n    };\n    onChange(data, itemRefs);\n  }, [onKeyDown, stopPropagation, focusedIndex, keys, items, handleSearch, loopable, searchable, onChange, itemRefs]);\n  return [itemRefs, handleKeyDown];\n}","map":{"version":3,"sources":["../../../src/wia-aria/movement/useKeyboardMovement.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nimport { useCallback, useMemo } from \"react\";\nimport { loop } from \"../../loop\";\nimport { useKeyboardSearch, } from \"../../search/useKeyboardSearch\";\nimport { DEFAULT_GET_ITEM_VALUE, DEFAULT_VALUE_KEY } from \"../../search/utils\";\nimport { getKeyboardConfig, getStringifiedKeyConfig, transformKeys, } from \"./utils\";\n/**\n * This is a low-level hook for providing custom keyboard movement based on key\n * configurations.  This normally shouldn't really be used externally since\n * you'll most likely want to use the \"presets\" of `useFocusMovement` and\n * `useActiveDescendantMovement` that implement the main movement types already\n * for you.\n *\n * The way this works is that it will general a list of mutable item refs that\n * should be applied to each DOM node for the corresponding `item` within the\n * `items` list. This list will change and regenerate itself each time the\n * `items` array changes so it'll always be in-sync with the DOM nodes. This\n * means that if you have some items that **should not be rendered**, they\n * should not be included within the items list. The main reason these item refs\n * are required is so that the `aria-acativedescendant` movement can scroll the\n * new \"focused\" element into view if needed while the \"true\" focus movement can\n * trigger a `ref.current.focus()` on the new item as needed.\n *\n * Finally, this will create a keydown event handler that will merge in the\n * optionally provided `onKeyDown` prop and check if the pressed key should\n * trigger a custom keyboard movement event.  If it does, an `onChange` event\n * will be fired with the matching data and allows for custom movement with\n * `target.focus()` or updating the `aria-activedescendant` attribute as needed.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport function useKeyboardMovement(_a) {\n    var onKeyDown = _a.onKeyDown, incrementKeys = _a.incrementKeys, decrementKeys = _a.decrementKeys, jumpToFirstKeys = _a.jumpToFirstKeys, jumpToLastKeys = _a.jumpToLastKeys, _b = _a.stopPropagation, stopPropagation = _b === void 0 ? true : _b, onChange = _a.onChange, items = _a.items, resetTime = _a.resetTime, findMatchIndex = _a.findMatchIndex, focusedIndex = _a.focusedIndex, _c = _a.loopable, loopable = _c === void 0 ? true : _c, _d = _a.searchable, searchable = _d === void 0 ? true : _d, _e = _a.valueKey, valueKey = _e === void 0 ? DEFAULT_VALUE_KEY : _e, _f = _a.getItemValue, getItemValue = _f === void 0 ? DEFAULT_GET_ITEM_VALUE : _f;\n    var keys = useMemo(function () { return __spreadArray(__spreadArray(__spreadArray(__spreadArray([], transformKeys(incrementKeys, \"increment\")), transformKeys(decrementKeys, \"decrement\")), transformKeys(jumpToFirstKeys, \"first\")), transformKeys(jumpToLastKeys, \"last\")); }, [incrementKeys, decrementKeys, jumpToFirstKeys, jumpToLastKeys]);\n    var itemRefs = useMemo(function () { return Array.from(items, function () { return ({ current: null }); }); }, [items]);\n    var handleSearch = useKeyboardSearch({\n        items: items,\n        valueKey: valueKey,\n        getItemValue: getItemValue,\n        onChange: function (data) {\n            onChange(data, itemRefs);\n        },\n        searchIndex: focusedIndex,\n        resetTime: resetTime,\n        findMatchIndex: findMatchIndex,\n    });\n    var handleKeyDown = useCallback(function (event) {\n        if (searchable) {\n            handleSearch(event);\n        }\n        if (onKeyDown) {\n            onKeyDown(event);\n        }\n        var target = event.target;\n        var keyConfig = getKeyboardConfig(event, keys);\n        if (!keyConfig || !target) {\n            return;\n        }\n        // implementing custom behavior, so prevent default of scrolling or other\n        // things\n        event.preventDefault();\n        if (stopPropagation) {\n            event.stopPropagation();\n        }\n        var type = keyConfig.type;\n        var lastIndex = items.length - 1;\n        var index;\n        switch (type) {\n            case \"first\":\n                index = 0;\n                break;\n            case \"last\":\n                index = lastIndex;\n                break;\n            default:\n                index = loop({\n                    value: focusedIndex,\n                    max: lastIndex,\n                    increment: type === \"increment\",\n                    minmax: !loopable,\n                });\n        }\n        if (index === focusedIndex) {\n            return;\n        }\n        var data = {\n            index: index,\n            item: items[index],\n            items: items,\n            query: getStringifiedKeyConfig(keyConfig),\n            target: event.currentTarget,\n        };\n        onChange(data, itemRefs);\n    }, [\n        onKeyDown,\n        stopPropagation,\n        focusedIndex,\n        keys,\n        items,\n        handleSearch,\n        loopable,\n        searchable,\n        onChange,\n        itemRefs,\n    ]);\n    return [itemRefs, handleKeyDown];\n}\n//# sourceMappingURL=useKeyboardMovement.js.map"]},"metadata":{},"sourceType":"module"}