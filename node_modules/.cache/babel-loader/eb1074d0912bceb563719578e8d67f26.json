{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { useState } from \"react\";\nimport { scrollIntoView } from \"../../scrollIntoView\";\nimport { DEFAULT_GET_ITEM_VALUE, DEFAULT_VALUE_KEY } from \"../../search/utils\";\nimport { useKeyboardMovement } from \"./useKeyboardMovement\";\nimport { getItemId } from \"./utils\";\n/**\n * This hook allows for custom keyboard \"focus\" movement using the\n * `aria-activedescendant` movement pattern. This is generally used when the DOM\n * focus shouldn't actually change from the container element (like listboxes)\n * but you still need to indicate that another element is \"focused\" due to a key\n * press.\n *\n * To use this hook, you'll want to update the container element of all the\n * items to have an `aria-activedescendant={activeId}` attribute and\n * `onKeyDown={onKeyDown}` that are provided by this hook. The\n * `aria-activedescendant` will help screen readers known what element is\n * \"focused\" since the container element should never really lose focus during\n * these keyboard movement events.  Finally, you'll want to update each item\n * have an id that is the result of `getItem(baseId, index)` so that it matches\n * the `aria-activedescendant` value and then apply `ref={itemRefs[i]}`.\n * Unfortunately, this means that all the child items **must** either be an\n * HTMLElement or the ref is forwarded down to the HTMLElement.\n *\n * The `itemRefs` **must** be applied so that a new \"focused\" item can be\n * scrolled into view as needed.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\n\nexport function useActiveDescendantMovement(_a) {\n  var baseId = _a.baseId,\n      _b = _a.getId,\n      getId = _b === void 0 ? getItemId : _b,\n      _c = _a.defaultFocusedIndex,\n      defaultFocusedIndex = _c === void 0 ? -1 : _c,\n      items = _a.items,\n      onChange = _a.onChange,\n      _d = _a.getItemValue,\n      getItemValue = _d === void 0 ? DEFAULT_GET_ITEM_VALUE : _d,\n      _e = _a.valueKey,\n      valueKey = _e === void 0 ? DEFAULT_VALUE_KEY : _e,\n      onKeyDown = _a.onKeyDown,\n      onEnter = _a.onEnter,\n      onSpace = _a.onSpace,\n      options = __rest(_a, [\"baseId\", \"getId\", \"defaultFocusedIndex\", \"items\", \"onChange\", \"getItemValue\", \"valueKey\", \"onKeyDown\", \"onEnter\", \"onSpace\"]);\n\n  var _f = useState(defaultFocusedIndex),\n      focusedIndex = _f[0],\n      setFocusedIndex = _f[1];\n\n  var activeId = focusedIndex !== -1 ? getId(baseId, focusedIndex) : \"\";\n\n  var _g = useKeyboardMovement(__assign(__assign({}, options), {\n    valueKey: valueKey,\n    getItemValue: getItemValue,\n    focusedIndex: focusedIndex,\n    items: items,\n    onChange: function (data, itemRefs) {\n      if (onChange) {\n        onChange(data, itemRefs);\n      }\n\n      var index = data.index,\n          target = data.target;\n      var item = itemRefs[index] && itemRefs[index].current;\n\n      if (item && target && target.scrollHeight > target.offsetHeight) {\n        scrollIntoView(target, item);\n      }\n\n      setFocusedIndex(index);\n    },\n    onKeyDown: function (event) {\n      if (onKeyDown) {\n        onKeyDown(event);\n      }\n\n      var ref = itemRefs[focusedIndex] && itemRefs[focusedIndex].current || null;\n\n      if (onEnter && event.key === \"Enter\") {\n        onEnter(focusedIndex, ref);\n      } else if (onSpace && event.key === \" \") {\n        event.preventDefault();\n        onSpace(focusedIndex, ref);\n      }\n    }\n  })),\n      itemRefs = _g[0],\n      handleKeyDown = _g[1];\n\n  return {\n    activeId: activeId,\n    itemRefs: itemRefs,\n    onKeyDown: handleKeyDown,\n    focusedIndex: focusedIndex,\n    setFocusedIndex: setFocusedIndex\n  };\n}","map":{"version":3,"sources":["../../../src/wia-aria/movement/useActiveDescendantMovement.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { useState } from \"react\";\nimport { scrollIntoView } from \"../../scrollIntoView\";\nimport { DEFAULT_GET_ITEM_VALUE, DEFAULT_VALUE_KEY } from \"../../search/utils\";\nimport { useKeyboardMovement, } from \"./useKeyboardMovement\";\nimport { getItemId } from \"./utils\";\n/**\n * This hook allows for custom keyboard \"focus\" movement using the\n * `aria-activedescendant` movement pattern. This is generally used when the DOM\n * focus shouldn't actually change from the container element (like listboxes)\n * but you still need to indicate that another element is \"focused\" due to a key\n * press.\n *\n * To use this hook, you'll want to update the container element of all the\n * items to have an `aria-activedescendant={activeId}` attribute and\n * `onKeyDown={onKeyDown}` that are provided by this hook. The\n * `aria-activedescendant` will help screen readers known what element is\n * \"focused\" since the container element should never really lose focus during\n * these keyboard movement events.  Finally, you'll want to update each item\n * have an id that is the result of `getItem(baseId, index)` so that it matches\n * the `aria-activedescendant` value and then apply `ref={itemRefs[i]}`.\n * Unfortunately, this means that all the child items **must** either be an\n * HTMLElement or the ref is forwarded down to the HTMLElement.\n *\n * The `itemRefs` **must** be applied so that a new \"focused\" item can be\n * scrolled into view as needed.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport function useActiveDescendantMovement(_a) {\n    var baseId = _a.baseId, _b = _a.getId, getId = _b === void 0 ? getItemId : _b, _c = _a.defaultFocusedIndex, defaultFocusedIndex = _c === void 0 ? -1 : _c, items = _a.items, onChange = _a.onChange, _d = _a.getItemValue, getItemValue = _d === void 0 ? DEFAULT_GET_ITEM_VALUE : _d, _e = _a.valueKey, valueKey = _e === void 0 ? DEFAULT_VALUE_KEY : _e, onKeyDown = _a.onKeyDown, onEnter = _a.onEnter, onSpace = _a.onSpace, options = __rest(_a, [\"baseId\", \"getId\", \"defaultFocusedIndex\", \"items\", \"onChange\", \"getItemValue\", \"valueKey\", \"onKeyDown\", \"onEnter\", \"onSpace\"]);\n    var _f = useState(defaultFocusedIndex), focusedIndex = _f[0], setFocusedIndex = _f[1];\n    var activeId = focusedIndex !== -1 ? getId(baseId, focusedIndex) : \"\";\n    var _g = useKeyboardMovement(__assign(__assign({}, options), { valueKey: valueKey,\n        getItemValue: getItemValue,\n        focusedIndex: focusedIndex,\n        items: items,\n        onChange: function (data, itemRefs) {\n            if (onChange) {\n                onChange(data, itemRefs);\n            }\n            var index = data.index, target = data.target;\n            var item = itemRefs[index] && itemRefs[index].current;\n            if (item && target && target.scrollHeight > target.offsetHeight) {\n                scrollIntoView(target, item);\n            }\n            setFocusedIndex(index);\n        },\n        onKeyDown: function (event) {\n            if (onKeyDown) {\n                onKeyDown(event);\n            }\n            var ref = (itemRefs[focusedIndex] && itemRefs[focusedIndex].current) || null;\n            if (onEnter && event.key === \"Enter\") {\n                onEnter(focusedIndex, ref);\n            }\n            else if (onSpace && event.key === \" \") {\n                event.preventDefault();\n                onSpace(focusedIndex, ref);\n            }\n        } })), itemRefs = _g[0], handleKeyDown = _g[1];\n    return {\n        activeId: activeId,\n        itemRefs: itemRefs,\n        onKeyDown: handleKeyDown,\n        focusedIndex: focusedIndex,\n        setFocusedIndex: setFocusedIndex,\n    };\n}\n//# sourceMappingURL=useActiveDescendantMovement.js.map"]},"metadata":{},"sourceType":"module"}