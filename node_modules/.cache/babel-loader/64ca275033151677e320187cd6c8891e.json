{"ast":null,"code":"/**\n * Creates the `left` style value for an element that should be fixed to the\n * (outer) left of the container element. So the right bounds of the fixed\n * element will be equal to the left bounds of the container element (before the\n * xMargin is applied).\n * @internal\n */\nexport function getLeftCoord(_a) {\n  var xMargin = _a.xMargin,\n      elWidth = _a.elWidth,\n      initialX = _a.initialX,\n      containerRect = _a.containerRect;\n  return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left) - elWidth - xMargin;\n}\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * inner-left of the container element. So the left bounds of both the container\n * and fixed elements will overlap (before the xMargin is applied)\n * @internal\n */\n\nexport function getInnerLeftCoord(_a) {\n  var xMargin = _a.xMargin,\n      initialX = _a.initialX,\n      containerRect = _a.containerRect;\n  return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left) + xMargin;\n}\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * center of the container element. So the center point of the fixed element\n * should be the center point of the container element.\n *\n * Note: Unlike all the other horizontal positioning logic, the center position\n * does not use the xMargin.\n * @internal\n */\n\nexport function getCenterXCoord(_a) {\n  var elWidth = _a.elWidth,\n      initialX = _a.initialX,\n      containerRect = _a.containerRect;\n  var containerCenter = containerRect.width / 2;\n  var elementCenter = elWidth / 2;\n  return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left + containerCenter) - elementCenter;\n}\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * inner-right of the container element. So the right bounds for both the\n * container and fixed elements will overlap (before the xMargin is applied).\n * @internal\n */\n\nexport function getInnerRightCoord(_a) {\n  var xMargin = _a.xMargin,\n      elWidth = _a.elWidth,\n      initialX = _a.initialX,\n      containerRect = _a.containerRect;\n  return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left + containerRect.width) - elWidth - xMargin;\n}\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * (outer) right of the container element. So the left bounds of the fixed\n * element will overlap with the right bounds of the container element (before\n * the xMargin is applied).\n * @internal\n */\n\nexport function getRightCoord(_a) {\n  var xMargin = _a.xMargin,\n      initialX = _a.initialX,\n      containerRect = _a.containerRect;\n  return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left + containerRect.width) + xMargin;\n}\n/**\n * Creates the `top` style value for an element that should be fixed above the\n * container element. So the bottom bounds of the fixed element will overlap\n * with the top bounds of the container element (before the yMargin is applied).\n * @internal\n */\n\nexport function getAboveCoord(_a) {\n  var yMargin = _a.yMargin,\n      initialY = _a.initialY,\n      elHeight = _a.elHeight,\n      containerRect = _a.containerRect;\n  return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top) - elHeight - yMargin;\n}\n/**\n * Creates the `top` style value for an element that should be fixed to the top\n * of the container element. So the top bounds for both the container and fixed\n * elements will overlap (before the yMargin is applied).\n * @internal\n */\n\nexport function getTopCoord(_a) {\n  var yMargin = _a.yMargin,\n      initialY = _a.initialY,\n      containerRect = _a.containerRect;\n  return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top) + yMargin;\n}\n/**\n * Creates the `top` style value for an element that should be fixed vertically\n * centered relative to the container element. So the vertical center point for\n * the fixed element should overlap the vertical center point of the container\n * element.\n *\n * Note: Unlike all the other vertical positioning logic, the center position\n * does not use the yMargin.\n */\n\nexport function getCenterYCoord(_a) {\n  var elHeight = _a.elHeight,\n      initialY = _a.initialY,\n      containerRect = _a.containerRect;\n  var containerCenter = containerRect.height / 2;\n  var elementCenter = elHeight / 2;\n  return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top + containerCenter) - elementCenter;\n}\n/**\n * Creates the `top` style value for an element that should be fixed to the\n * bottom of the container element. So the top bounds of the fixed element\n * should overlap the bottom bounds of the container element (before the yMargin\n * is applied).\n * @internal\n */\n\nexport function getBottomCoord(_a) {\n  var yMargin = _a.yMargin,\n      initialY = _a.initialY,\n      elHeight = _a.elHeight,\n      containerRect = _a.containerRect;\n  return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top + containerRect.height) - elHeight - yMargin;\n}\n/**\n * Creates the `top` style value for an element that should be fixed to the\n * bottom of the container element. So the bottom bounds of both the container\n * and fixed elements should overlap (before the yMargin is applied).\n * @internal\n */\n\nexport function getBelowCoord(_a) {\n  var yMargin = _a.yMargin,\n      initialY = _a.initialY,\n      containerRect = _a.containerRect;\n  return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top + containerRect.height) + yMargin;\n}","map":{"version":3,"sources":["../../src/positioning/getCoord.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * Creates the `left` style value for an element that should be fixed to the\n * (outer) left of the container element. So the right bounds of the fixed\n * element will be equal to the left bounds of the container element (before the\n * xMargin is applied).\n * @internal\n */\nexport function getLeftCoord(_a) {\n    var xMargin = _a.xMargin, elWidth = _a.elWidth, initialX = _a.initialX, containerRect = _a.containerRect;\n    return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left) - elWidth - xMargin;\n}\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * inner-left of the container element. So the left bounds of both the container\n * and fixed elements will overlap (before the xMargin is applied)\n * @internal\n */\nexport function getInnerLeftCoord(_a) {\n    var xMargin = _a.xMargin, initialX = _a.initialX, containerRect = _a.containerRect;\n    return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left) + xMargin;\n}\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * center of the container element. So the center point of the fixed element\n * should be the center point of the container element.\n *\n * Note: Unlike all the other horizontal positioning logic, the center position\n * does not use the xMargin.\n * @internal\n */\nexport function getCenterXCoord(_a) {\n    var elWidth = _a.elWidth, initialX = _a.initialX, containerRect = _a.containerRect;\n    var containerCenter = containerRect.width / 2;\n    var elementCenter = elWidth / 2;\n    return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left + containerCenter) - elementCenter;\n}\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * inner-right of the container element. So the right bounds for both the\n * container and fixed elements will overlap (before the xMargin is applied).\n * @internal\n */\nexport function getInnerRightCoord(_a) {\n    var xMargin = _a.xMargin, elWidth = _a.elWidth, initialX = _a.initialX, containerRect = _a.containerRect;\n    return ((initialX !== null && initialX !== void 0 ? initialX : containerRect.left + containerRect.width) - elWidth - xMargin);\n}\n/**\n * Creates the `left` style value for an element that should be fixed to the\n * (outer) right of the container element. So the left bounds of the fixed\n * element will overlap with the right bounds of the container element (before\n * the xMargin is applied).\n * @internal\n */\nexport function getRightCoord(_a) {\n    var xMargin = _a.xMargin, initialX = _a.initialX, containerRect = _a.containerRect;\n    return (initialX !== null && initialX !== void 0 ? initialX : containerRect.left + containerRect.width) + xMargin;\n}\n/**\n * Creates the `top` style value for an element that should be fixed above the\n * container element. So the bottom bounds of the fixed element will overlap\n * with the top bounds of the container element (before the yMargin is applied).\n * @internal\n */\nexport function getAboveCoord(_a) {\n    var yMargin = _a.yMargin, initialY = _a.initialY, elHeight = _a.elHeight, containerRect = _a.containerRect;\n    return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top) - elHeight - yMargin;\n}\n/**\n * Creates the `top` style value for an element that should be fixed to the top\n * of the container element. So the top bounds for both the container and fixed\n * elements will overlap (before the yMargin is applied).\n * @internal\n */\nexport function getTopCoord(_a) {\n    var yMargin = _a.yMargin, initialY = _a.initialY, containerRect = _a.containerRect;\n    return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top) + yMargin;\n}\n/**\n * Creates the `top` style value for an element that should be fixed vertically\n * centered relative to the container element. So the vertical center point for\n * the fixed element should overlap the vertical center point of the container\n * element.\n *\n * Note: Unlike all the other vertical positioning logic, the center position\n * does not use the yMargin.\n */\nexport function getCenterYCoord(_a) {\n    var elHeight = _a.elHeight, initialY = _a.initialY, containerRect = _a.containerRect;\n    var containerCenter = containerRect.height / 2;\n    var elementCenter = elHeight / 2;\n    return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top + containerCenter) - elementCenter;\n}\n/**\n * Creates the `top` style value for an element that should be fixed to the\n * bottom of the container element. So the top bounds of the fixed element\n * should overlap the bottom bounds of the container element (before the yMargin\n * is applied).\n * @internal\n */\nexport function getBottomCoord(_a) {\n    var yMargin = _a.yMargin, initialY = _a.initialY, elHeight = _a.elHeight, containerRect = _a.containerRect;\n    return ((initialY !== null && initialY !== void 0 ? initialY : containerRect.top + containerRect.height) - elHeight - yMargin);\n}\n/**\n * Creates the `top` style value for an element that should be fixed to the\n * bottom of the container element. So the bottom bounds of both the container\n * and fixed elements should overlap (before the yMargin is applied).\n * @internal\n */\nexport function getBelowCoord(_a) {\n    var yMargin = _a.yMargin, initialY = _a.initialY, containerRect = _a.containerRect;\n    return (initialY !== null && initialY !== void 0 ? initialY : containerRect.top + containerRect.height) + yMargin;\n}\n//# sourceMappingURL=getCoord.js.map"]},"metadata":{},"sourceType":"module"}