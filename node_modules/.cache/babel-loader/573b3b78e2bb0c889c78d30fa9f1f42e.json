{"ast":null,"code":"import { createHorizontalPosition } from \"./createHorizontalPosition\";\nimport { createVerticalPosition } from \"./createVerticalPosition\";\nimport { findSizingContainer } from \"./findSizingContainer\";\nimport { getElementRect } from \"./getElementRect\";\nimport { getTransformOrigin } from \"./getTransformOrigin\";\nimport { getViewportSize } from \"./getViewportSize\";\n/**\n * One of the most complicated functions in this project that will attempt to\n * position an element relative to another container element while still being\n * visible within the viewport. Below is the logical flow for attempting to fix\n * the element to the container:\n *\n * No Container: If there is no container element, return the provided x and y\n * positions and no styles since there's nothing we can use to calculate the\n * position.\n *\n * No Element: If the container was provided but the element to position does\n * not exist, return an style object containing the `left` and `top` values for\n * the container and apply as many of the positioning options as possible so\n * that the styles are \"as close as possible\" before the fixed element is added\n * to the DOM. This will also return the provided x and y positions since\n * nothing could be swapped around yet.\n *\n * Container and Element: If both the container and fixed element were provided,\n * apply all the positioning options to the `left` and `top` values of the\n * container based on the sizes of both elements.\n *\n * Now that the `left` and `top` values were applied, check to see if the\n * element is fully visible within the viewport with the provided positioning\n * options. If it is fully visible, do nothing else. If it isn't... follow the\n * next flow:\n *\n * First, check the horizontal sizes and make sure that the element is still\n * within the viewport with the provided viewwidth margin. If it isn't, first\n * try to swap only to a `right` style instead of left to see if that fixes it,\n * otherwise keep both the `left` and `right` styles.\n */\n\nexport function getFixedPosition(_a) {\n  var container = _a.container,\n      element = _a.element,\n      _b = _a.anchor,\n      propAnchor = _b === void 0 ? {} : _b,\n      initialX = _a.initialX,\n      initialY = _a.initialY,\n      _c = _a.vwMargin,\n      vwMargin = _c === void 0 ? 16 : _c,\n      _d = _a.vhMargin,\n      vhMargin = _d === void 0 ? 16 : _d,\n      _e = _a.xMargin,\n      xMargin = _e === void 0 ? 0 : _e,\n      _f = _a.yMargin,\n      yMargin = _f === void 0 ? 0 : _f,\n      _g = _a.width,\n      widthType = _g === void 0 ? \"auto\" : _g,\n      _h = _a.preventOverlap,\n      preventOverlap = _h === void 0 ? false : _h,\n      _j = _a.transformOrigin,\n      transformOrigin = _j === void 0 ? false : _j,\n      _k = _a.disableSwapping,\n      disableSwapping = _k === void 0 ? false : _k,\n      _l = _a.disableVHBounds,\n      disableVHBounds = _l === void 0 ? false : _l;\n  container = findSizingContainer(container);\n  var anchor = {\n    x: propAnchor.x || \"center\",\n    y: propAnchor.y || \"below\"\n  };\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (widthType !== \"auto\" && anchor.x !== \"center\") {\n      throw new Error('Unable to use a calculated width when the horizontal anchor is not `\"center\"`.');\n    }\n\n    if (preventOverlap && anchor.y !== \"above\" && anchor.y !== \"below\") {\n      throw new Error('Unable to prevent overlap when the vertical anchor is not `\"above\"` or `\"below\"`');\n    }\n  }\n\n  if (!container || !element) {\n    return {\n      actualX: anchor.x,\n      actualY: anchor.y\n    };\n  }\n\n  var containerRect = container.getBoundingClientRect();\n  var vh = getViewportSize(\"height\");\n  var vw = getViewportSize(\"width\");\n\n  var _m = getElementRect(element),\n      height = _m.height,\n      elWidth = _m.width;\n\n  if (disableVHBounds) {\n    var dialog = element.closest(\"[role='dialog']\");\n\n    if (!dialog) {\n      initialY = (initialY !== null && initialY !== void 0 ? initialY : 0) + window.scrollY;\n    }\n  }\n\n  var _o = createHorizontalPosition({\n    x: anchor.x,\n    vw: vw,\n    vwMargin: vwMargin,\n    xMargin: xMargin,\n    width: widthType,\n    elWidth: elWidth,\n    initialX: initialX,\n    containerRect: containerRect,\n    disableSwapping: disableSwapping\n  }),\n      left = _o.left,\n      right = _o.right,\n      width = _o.width,\n      minWidth = _o.minWidth,\n      actualX = _o.actualX;\n\n  var _p = createVerticalPosition({\n    y: anchor.y,\n    vh: vh,\n    vhMargin: vhMargin,\n    yMargin: yMargin,\n    initialY: initialY,\n    elHeight: height,\n    containerRect: containerRect,\n    disableSwapping: disableSwapping,\n    preventOverlap: preventOverlap,\n    disableVHBounds: disableVHBounds\n  }),\n      top = _p.top,\n      bottom = _p.bottom,\n      actualY = _p.actualY;\n\n  return {\n    actualX: actualX,\n    actualY: actualY,\n    style: {\n      left: left,\n      top: top,\n      right: right,\n      bottom: bottom,\n      width: width,\n      minWidth: minWidth,\n      position: disableVHBounds ? \"absolute\" : \"fixed\",\n      transformOrigin: transformOrigin ? getTransformOrigin({\n        x: actualX,\n        y: actualY\n      }) : undefined\n    }\n  };\n}","map":{"version":3,"sources":["../../src/positioning/getFixedPosition.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { createHorizontalPosition } from \"./createHorizontalPosition\";\nimport { createVerticalPosition } from \"./createVerticalPosition\";\nimport { findSizingContainer } from \"./findSizingContainer\";\nimport { getElementRect } from \"./getElementRect\";\nimport { getTransformOrigin } from \"./getTransformOrigin\";\nimport { getViewportSize } from \"./getViewportSize\";\n/**\n * One of the most complicated functions in this project that will attempt to\n * position an element relative to another container element while still being\n * visible within the viewport. Below is the logical flow for attempting to fix\n * the element to the container:\n *\n * No Container: If there is no container element, return the provided x and y\n * positions and no styles since there's nothing we can use to calculate the\n * position.\n *\n * No Element: If the container was provided but the element to position does\n * not exist, return an style object containing the `left` and `top` values for\n * the container and apply as many of the positioning options as possible so\n * that the styles are \"as close as possible\" before the fixed element is added\n * to the DOM. This will also return the provided x and y positions since\n * nothing could be swapped around yet.\n *\n * Container and Element: If both the container and fixed element were provided,\n * apply all the positioning options to the `left` and `top` values of the\n * container based on the sizes of both elements.\n *\n * Now that the `left` and `top` values were applied, check to see if the\n * element is fully visible within the viewport with the provided positioning\n * options. If it is fully visible, do nothing else. If it isn't... follow the\n * next flow:\n *\n * First, check the horizontal sizes and make sure that the element is still\n * within the viewport with the provided viewwidth margin. If it isn't, first\n * try to swap only to a `right` style instead of left to see if that fixes it,\n * otherwise keep both the `left` and `right` styles.\n */\nexport function getFixedPosition(_a) {\n    var container = _a.container, element = _a.element, _b = _a.anchor, propAnchor = _b === void 0 ? {} : _b, initialX = _a.initialX, initialY = _a.initialY, _c = _a.vwMargin, vwMargin = _c === void 0 ? 16 : _c, _d = _a.vhMargin, vhMargin = _d === void 0 ? 16 : _d, _e = _a.xMargin, xMargin = _e === void 0 ? 0 : _e, _f = _a.yMargin, yMargin = _f === void 0 ? 0 : _f, _g = _a.width, widthType = _g === void 0 ? \"auto\" : _g, _h = _a.preventOverlap, preventOverlap = _h === void 0 ? false : _h, _j = _a.transformOrigin, transformOrigin = _j === void 0 ? false : _j, _k = _a.disableSwapping, disableSwapping = _k === void 0 ? false : _k, _l = _a.disableVHBounds, disableVHBounds = _l === void 0 ? false : _l;\n    container = findSizingContainer(container);\n    var anchor = {\n        x: propAnchor.x || \"center\",\n        y: propAnchor.y || \"below\",\n    };\n    if (process.env.NODE_ENV !== \"production\") {\n        if (widthType !== \"auto\" && anchor.x !== \"center\") {\n            throw new Error('Unable to use a calculated width when the horizontal anchor is not `\"center\"`.');\n        }\n        if (preventOverlap && anchor.y !== \"above\" && anchor.y !== \"below\") {\n            throw new Error('Unable to prevent overlap when the vertical anchor is not `\"above\"` or `\"below\"`');\n        }\n    }\n    if (!container || !element) {\n        return {\n            actualX: anchor.x,\n            actualY: anchor.y,\n        };\n    }\n    var containerRect = container.getBoundingClientRect();\n    var vh = getViewportSize(\"height\");\n    var vw = getViewportSize(\"width\");\n    var _m = getElementRect(element), height = _m.height, elWidth = _m.width;\n    if (disableVHBounds) {\n        var dialog = element.closest(\"[role='dialog']\");\n        if (!dialog) {\n            initialY = (initialY !== null && initialY !== void 0 ? initialY : 0) + window.scrollY;\n        }\n    }\n    var _o = createHorizontalPosition({\n        x: anchor.x,\n        vw: vw,\n        vwMargin: vwMargin,\n        xMargin: xMargin,\n        width: widthType,\n        elWidth: elWidth,\n        initialX: initialX,\n        containerRect: containerRect,\n        disableSwapping: disableSwapping,\n    }), left = _o.left, right = _o.right, width = _o.width, minWidth = _o.minWidth, actualX = _o.actualX;\n    var _p = createVerticalPosition({\n        y: anchor.y,\n        vh: vh,\n        vhMargin: vhMargin,\n        yMargin: yMargin,\n        initialY: initialY,\n        elHeight: height,\n        containerRect: containerRect,\n        disableSwapping: disableSwapping,\n        preventOverlap: preventOverlap,\n        disableVHBounds: disableVHBounds,\n    }), top = _p.top, bottom = _p.bottom, actualY = _p.actualY;\n    return {\n        actualX: actualX,\n        actualY: actualY,\n        style: {\n            left: left,\n            top: top,\n            right: right,\n            bottom: bottom,\n            width: width,\n            minWidth: minWidth,\n            position: disableVHBounds ? \"absolute\" : \"fixed\",\n            transformOrigin: transformOrigin\n                ? getTransformOrigin({ x: actualX, y: actualY })\n                : undefined,\n        },\n    };\n}\n//# sourceMappingURL=getFixedPosition.js.map"]},"metadata":{},"sourceType":"module"}