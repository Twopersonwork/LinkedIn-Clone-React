{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { useEffect, useState } from \"react\";\nimport { useKeyboardMovement } from \"./useKeyboardMovement\";\n/**\n * This hook allows for custom keyboard focus movement using DOM focus behavior\n * by actually focusing each DOM node.\n *\n * To use this hook, you'll want to update the container element of all the\n * items to have a correct `role` applied as well as the `onKeyDown` event\n * handler provided by this hook. Then, you'll want to applied a\n * `ref={itemRefs[i]}` for each item within the items list so that the DOM nodes\n * can be focused as needed. Unfortunately, this means that all the child items\n * **must** either be an HTMLElement or the ref is forwarded down to the\n * HTMLElement.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\n\nexport function useFocusMovement(_a) {\n  var _b = _a.defaultFocusedIndex,\n      defaultFocusedIndex = _b === void 0 ? -1 : _b,\n      onChange = _a.onChange,\n      options = __rest(_a, [\"defaultFocusedIndex\", \"onChange\"]);\n\n  var _c = useState(defaultFocusedIndex),\n      focusedIndex = _c[0],\n      setFocusedIndex = _c[1];\n\n  var _d = useKeyboardMovement(__assign(__assign({}, options), {\n    focusedIndex: focusedIndex,\n    onChange: function (data, itemRefs) {\n      if (onChange) {\n        onChange(data, itemRefs);\n      }\n\n      var index = data.index;\n\n      if (index === -1) {\n        return;\n      }\n\n      var item = itemRefs[index] && itemRefs[index].current;\n\n      if (item) {\n        item.focus();\n      }\n\n      setFocusedIndex(index);\n    }\n  })),\n      itemRefs = _d[0],\n      handleKeyDown = _d[1];\n\n  useEffect(function () {\n    if (defaultFocusedIndex === -1) {\n      return;\n    }\n\n    var item = itemRefs[defaultFocusedIndex] && itemRefs[defaultFocusedIndex].current;\n\n    if (item) {\n      item.focus();\n    } // only want to trigger on mount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  return [itemRefs, handleKeyDown];\n}","map":{"version":3,"sources":["../../../src/wia-aria/movement/useFocusMovement.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAS,SAAT,EAAoB,QAApB,QAAoC,OAApC;AAEA,SAGE,mBAHF,QAIO,uBAJP;AAiBA;;;;;;;;;;;;;;;;;AAiBG;;AACH,OAAM,SAAU,gBAAV,CAIJ,EAJI,EAQ4B;AAHhC,MAAA,EAAA,GAAA,EAAA,CAAA,mBAAA;AAAA,MAAA,mBAAmB,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,CAAC,CAAJ,GAAK,EAAxB;AAAA,MACA,QAAQ,GAAA,EAAA,CAAA,QADR;AAAA,MAEG,OAAO,GAAA,MAAA,CAAA,EAAA,EAHV,CAAA,qBAAA,EAAA,UAAA,CAGU,CAFV;;AAIM,MAAA,EAAA,GAAkC,QAAQ,CAAC,mBAAD,CAA1C;AAAA,MAAC,YAAY,GAAA,EAAA,CAAA,CAAA,CAAb;AAAA,MAAe,eAAe,GAAA,EAAA,CAAA,CAAA,CAA9B;;AACA,MAAA,EAAA,GAA4B,mBAAmB,CAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAChD,OADgD,CAAA,EACzC;AACV,IAAA,YAAY,EAAA,YADF;AAEV,IAAA,QAAQ,EAAA,UAAC,IAAD,EAAO,QAAP,EAAe;AACrB,UAAI,QAAJ,EAAc;AACZ,QAAA,QAAQ,CAAC,IAAD,EAAO,QAAP,CAAR;AACD;;AAEO,UAAA,KAAK,GAAK,IAAI,CAAT,KAAL;;AACR,UAAI,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChB;AACD;;AAED,UAAM,IAAI,GAAG,QAAQ,CAAC,KAAD,CAAR,IAAmB,QAAQ,CAAC,KAAD,CAAR,CAAgB,OAAhD;;AACA,UAAI,IAAJ,EAAU;AACR,QAAA,IAAI,CAAC,KAAL;AACD;;AAED,MAAA,eAAe,CAAC,KAAD,CAAf;AACD;AAlBS,GADyC,CAAA,CAA/C;AAAA,MAAC,QAAQ,GAAA,EAAA,CAAA,CAAA,CAAT;AAAA,MAAW,aAAa,GAAA,EAAA,CAAA,CAAA,CAAxB;;AAsBN,EAAA,SAAS,CAAC,YAAA;AACR,QAAI,mBAAmB,KAAK,CAAC,CAA7B,EAAgC;AAC9B;AACD;;AAED,QAAM,IAAI,GACR,QAAQ,CAAC,mBAAD,CAAR,IAAiC,QAAQ,CAAC,mBAAD,CAAR,CAA8B,OADjE;;AAEA,QAAI,IAAJ,EAAU;AACR,MAAA,IAAI,CAAC,KAAL;AACD,KATO,CAWR;AACA;;AACD,GAbQ,EAaN,EAbM,CAAT;AAeA,SAAO,CAAC,QAAD,EAAW,aAAX,CAAP;AACD","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { useEffect, useState } from \"react\";\nimport { useKeyboardMovement, } from \"./useKeyboardMovement\";\n/**\n * This hook allows for custom keyboard focus movement using DOM focus behavior\n * by actually focusing each DOM node.\n *\n * To use this hook, you'll want to update the container element of all the\n * items to have a correct `role` applied as well as the `onKeyDown` event\n * handler provided by this hook. Then, you'll want to applied a\n * `ref={itemRefs[i]}` for each item within the items list so that the DOM nodes\n * can be focused as needed. Unfortunately, this means that all the child items\n * **must** either be an HTMLElement or the ref is forwarded down to the\n * HTMLElement.\n *\n * @typeParam D - The type of each data item within the items list.\n * @typeParam CE - The HTMLElement type of the container element that handles\n * the custom keyboard movement.\n * @typeParam IE - The HTMLElement type of each item within the container\n * element that can be focusable.\n */\nexport function useFocusMovement(_a) {\n    var _b = _a.defaultFocusedIndex, defaultFocusedIndex = _b === void 0 ? -1 : _b, onChange = _a.onChange, options = __rest(_a, [\"defaultFocusedIndex\", \"onChange\"]);\n    var _c = useState(defaultFocusedIndex), focusedIndex = _c[0], setFocusedIndex = _c[1];\n    var _d = useKeyboardMovement(__assign(__assign({}, options), { focusedIndex: focusedIndex,\n        onChange: function (data, itemRefs) {\n            if (onChange) {\n                onChange(data, itemRefs);\n            }\n            var index = data.index;\n            if (index === -1) {\n                return;\n            }\n            var item = itemRefs[index] && itemRefs[index].current;\n            if (item) {\n                item.focus();\n            }\n            setFocusedIndex(index);\n        } })), itemRefs = _d[0], handleKeyDown = _d[1];\n    useEffect(function () {\n        if (defaultFocusedIndex === -1) {\n            return;\n        }\n        var item = itemRefs[defaultFocusedIndex] && itemRefs[defaultFocusedIndex].current;\n        if (item) {\n            item.focus();\n        }\n        // only want to trigger on mount\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    return [itemRefs, handleKeyDown];\n}\n//# sourceMappingURL=useFocusMovement.js.map"]},"metadata":{},"sourceType":"module"}