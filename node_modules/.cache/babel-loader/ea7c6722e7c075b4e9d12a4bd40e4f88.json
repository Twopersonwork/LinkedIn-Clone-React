{"ast":null,"code":"/**\n * Creates a throttled version of a function so that it'll be called with\n * trailing and leading calls. Since I always get this confused with `debounce`,\n * here's a quick summary of the differences:\n *\n * - debounce will wait to call the function until it hasn't been called again\n *   for the wait duration without trailing or leading calls. If it has the\n *   trailing and leading calls, I can't figure out how it's different than\n *   throttle.\n * - throttle will be called each time it is available to be called.\n *\n * So debounce is great for things like auto-save features if you want to save\n * whenever the user stops typing for a few seconds while throttle is good for\n * things like sending an API request when the user is typing so that it isn't\n * sent every keystroke, but every few letters. You _could_ also do debounce\n * here, but it'll feel more \"responsive\" to the user when throttled.\n *\n * @param fn - The function that should be throttled\n * @param wait - The number of milliseconds to wait before calling the function\n * again\n * @returns a throttled version of the function that'll return the last computed\n * value if it was called again during the \"wait\" period.\n */\nexport function throttle(fn, wait) {\n  var lastCalledTime = 0;\n  var timeout;\n  var result;\n  var args;\n\n  function trailingCall() {\n    lastCalledTime = Date.now();\n    timeout = undefined;\n    result = fn.apply(void 0, args);\n  }\n\n  return function throttled() {\n    var nextArgs = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      nextArgs[_i] = arguments[_i];\n    }\n\n    args = nextArgs;\n    var now = Date.now();\n    var remaining = wait - (now - lastCalledTime);\n\n    if (remaining <= 0 || remaining > wait) {\n      lastCalledTime = now;\n      result = fn.apply(void 0, args);\n    } else if (!timeout) {\n      timeout = window.setTimeout(trailingCall, remaining);\n    }\n\n    return result;\n  };\n}","map":{"version":3,"sources":["../src/throttle.ts"],"names":[],"mappings":"AAcA;;;;;;;;;;;;;;;;;;;;;;AAsBG;AACH,OAAM,SAAU,QAAV,CACJ,EADI,EAEJ,IAFI,EAEQ;AAEZ,MAAI,cAAc,GAAG,CAArB;AACA,MAAI,OAAJ;AACA,MAAI,MAAJ;AACA,MAAI,IAAJ;;AAEA,WAAS,YAAT,GAAqB;AACnB,IAAA,cAAc,GAAG,IAAI,CAAC,GAAL,EAAjB;AACA,IAAA,OAAO,GAAG,SAAV;AACA,IAAA,MAAM,GAAG,EAAE,CAAA,KAAF,CAAE,KAAA,CAAF,EAAM,IAAN,CAAT;AACD;;AAED,SAAO,SAAS,SAAT,GAAkB;AAAC,QAAA,QAAA,GAAA,EAAA;;SAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAA0B;AAA1B,MAAA,QAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACxB,IAAA,IAAI,GAAG,QAAP;AAEA,QAAM,GAAG,GAAG,IAAI,CAAC,GAAL,EAAZ;AACA,QAAM,SAAS,GAAG,IAAI,IAAI,GAAG,GAAG,cAAV,CAAtB;;AACA,QAAI,SAAS,IAAI,CAAb,IAAkB,SAAS,GAAG,IAAlC,EAAwC;AACtC,MAAA,cAAc,GAAG,GAAjB;AACA,MAAA,MAAM,GAAG,EAAE,CAAA,KAAF,CAAE,KAAA,CAAF,EAAM,IAAN,CAAT;AACD,KAHD,MAGO,IAAI,CAAC,OAAL,EAAc;AACnB,MAAA,OAAO,GAAG,MAAM,CAAC,UAAP,CAAkB,YAAlB,EAAgC,SAAhC,CAAV;AACD;;AAED,WAAO,MAAP;AACD,GAbD;AAcD","sourceRoot":"","sourcesContent":["/**\n * Creates a throttled version of a function so that it'll be called with\n * trailing and leading calls. Since I always get this confused with `debounce`,\n * here's a quick summary of the differences:\n *\n * - debounce will wait to call the function until it hasn't been called again\n *   for the wait duration without trailing or leading calls. If it has the\n *   trailing and leading calls, I can't figure out how it's different than\n *   throttle.\n * - throttle will be called each time it is available to be called.\n *\n * So debounce is great for things like auto-save features if you want to save\n * whenever the user stops typing for a few seconds while throttle is good for\n * things like sending an API request when the user is typing so that it isn't\n * sent every keystroke, but every few letters. You _could_ also do debounce\n * here, but it'll feel more \"responsive\" to the user when throttled.\n *\n * @param fn - The function that should be throttled\n * @param wait - The number of milliseconds to wait before calling the function\n * again\n * @returns a throttled version of the function that'll return the last computed\n * value if it was called again during the \"wait\" period.\n */\nexport function throttle(fn, wait) {\n    var lastCalledTime = 0;\n    var timeout;\n    var result;\n    var args;\n    function trailingCall() {\n        lastCalledTime = Date.now();\n        timeout = undefined;\n        result = fn.apply(void 0, args);\n    }\n    return function throttled() {\n        var nextArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            nextArgs[_i] = arguments[_i];\n        }\n        args = nextArgs;\n        var now = Date.now();\n        var remaining = wait - (now - lastCalledTime);\n        if (remaining <= 0 || remaining > wait) {\n            lastCalledTime = now;\n            result = fn.apply(void 0, args);\n        }\n        else if (!timeout) {\n            timeout = window.setTimeout(trailingCall, remaining);\n        }\n        return result;\n    };\n}\n//# sourceMappingURL=throttle.js.map"]},"metadata":{},"sourceType":"module"}