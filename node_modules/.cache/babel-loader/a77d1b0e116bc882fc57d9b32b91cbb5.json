{"ast":null,"code":"var cached = {\n  height: undefined,\n  width: undefined\n};\n/**\n * This is used to reset the cached value for each test and verify the cached\n * behavior is working\n * @internal\n */\n\nexport var reset = function () {\n  cached.height = undefined;\n  cached.width = undefined;\n};\n/**\n * This will return the scrollbar size for a specific OS by creating a\n * temporary element to compare the height/width between it's inner element and\n * it's own height/width when scrollbars are enabled. This is useful when your\n * height/width calculations need to exclude scrollbars since they are included\n * by default but content can't be shown underneath them for for static\n * elements.\n *\n * Note: This will return `0` on Mac OS with the default \"Only show scrollbars\n * when scrolling\" which is to be expected. These scrollbars overlay the content\n * and actually don't take up height/width real estate.\n *\n * @see https://stackoverflow.com/a/13382873\n * @param type - Either the string \"height\" or \"width\" to determine which size\n * to get\n * @param forced - Boolean if the scrollbar height/width should be force\n * updated. When this is false, the \"cached\" value will be returned immediately\n * instead\n * @returns the current scrollbar width or -1 if running this on the server\n */\n\nexport function scrollbarSize(type, forced) {\n  if (type === void 0) {\n    type = \"width\";\n  }\n\n  if (forced === void 0) {\n    forced = false;\n  }\n  /* istanbul ignore if */\n\n\n  if (typeof window === \"undefined\") {\n    return -1;\n  }\n\n  var value = cached[type];\n\n  if (!forced && typeof value === \"number\") {\n    return value;\n  }\n\n  var outer = document.createElement(\"div\");\n  outer.style.visibility = \"hidden\";\n  outer.style.overflow = \"scroll\";\n  document.body.appendChild(outer);\n  var inner = document.createElement(\"div\");\n  outer.appendChild(inner);\n  var offsetType = type === \"width\" ? \"offsetWidth\" : \"offsetHeight\"; // the scrollbar width can be determined by comparing the width of the parent\n  // element that has scrollbars to the child element that does not.\n\n  value = outer[offsetType] - inner[offsetType];\n  cached[type] = value;\n  document.body.removeChild(outer);\n  return value;\n}","map":{"version":3,"sources":["../../src/layout/scrollbarSize.ts"],"names":[],"mappings":"AAOA,IAAM,MAAM,GAAU;AACpB,EAAA,MAAM,EAAE,SADY;AAEpB,EAAA,KAAK,EAAE;AAFa,CAAtB;AAKA;;;;AAIG;;AACH,OAAO,IAAM,KAAK,GAAG,YAAA;AACnB,EAAA,MAAM,CAAC,MAAP,GAAgB,SAAhB;AACA,EAAA,MAAM,CAAC,KAAP,GAAe,SAAf;AACD,CAHM;AAKP;;;;;;;;;;;;;;;;;;;AAmBG;;AACH,OAAM,SAAU,aAAV,CACJ,IADI,EAEJ,MAFI,EAEU;AADd,MAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,IAAA,GAAA,OAAA;AAA0B;;AAC1B,MAAA,MAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,MAAA,GAAA,KAAA;AAAc;AAEd;;;AACA,MAAI,OAAO,MAAP,KAAkB,WAAtB,EAAmC;AACjC,WAAO,CAAC,CAAR;AACD;;AAED,MAAI,KAAK,GAAG,MAAM,CAAC,IAAD,CAAlB;;AACA,MAAI,CAAC,MAAD,IAAW,OAAO,KAAP,KAAiB,QAAhC,EAA0C;AACxC,WAAO,KAAP;AACD;;AAED,MAAM,KAAK,GAAG,QAAQ,CAAC,aAAT,CAAuB,KAAvB,CAAd;AACA,EAAA,KAAK,CAAC,KAAN,CAAY,UAAZ,GAAyB,QAAzB;AACA,EAAA,KAAK,CAAC,KAAN,CAAY,QAAZ,GAAuB,QAAvB;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,WAAd,CAA0B,KAA1B;AAEA,MAAM,KAAK,GAAG,QAAQ,CAAC,aAAT,CAAuB,KAAvB,CAAd;AACA,EAAA,KAAK,CAAC,WAAN,CAAkB,KAAlB;AAEA,MAAM,UAAU,GAAG,IAAI,KAAK,OAAT,GAAmB,aAAnB,GAAmC,cAAtD,CApBc,CAsBd;AACA;;AACA,EAAA,KAAK,GAAG,KAAK,CAAC,UAAD,CAAL,GAAoB,KAAK,CAAC,UAAD,CAAjC;AACA,EAAA,MAAM,CAAC,IAAD,CAAN,GAAe,KAAf;AACA,EAAA,QAAQ,CAAC,IAAT,CAAc,WAAd,CAA0B,KAA1B;AAEA,SAAO,KAAP;AACD","sourceRoot":"","sourcesContent":["var cached = {\n    height: undefined,\n    width: undefined,\n};\n/**\n * This is used to reset the cached value for each test and verify the cached\n * behavior is working\n * @internal\n */\nexport var reset = function () {\n    cached.height = undefined;\n    cached.width = undefined;\n};\n/**\n * This will return the scrollbar size for a specific OS by creating a\n * temporary element to compare the height/width between it's inner element and\n * it's own height/width when scrollbars are enabled. This is useful when your\n * height/width calculations need to exclude scrollbars since they are included\n * by default but content can't be shown underneath them for for static\n * elements.\n *\n * Note: This will return `0` on Mac OS with the default \"Only show scrollbars\n * when scrolling\" which is to be expected. These scrollbars overlay the content\n * and actually don't take up height/width real estate.\n *\n * @see https://stackoverflow.com/a/13382873\n * @param type - Either the string \"height\" or \"width\" to determine which size\n * to get\n * @param forced - Boolean if the scrollbar height/width should be force\n * updated. When this is false, the \"cached\" value will be returned immediately\n * instead\n * @returns the current scrollbar width or -1 if running this on the server\n */\nexport function scrollbarSize(type, forced) {\n    if (type === void 0) { type = \"width\"; }\n    if (forced === void 0) { forced = false; }\n    /* istanbul ignore if */\n    if (typeof window === \"undefined\") {\n        return -1;\n    }\n    var value = cached[type];\n    if (!forced && typeof value === \"number\") {\n        return value;\n    }\n    var outer = document.createElement(\"div\");\n    outer.style.visibility = \"hidden\";\n    outer.style.overflow = \"scroll\";\n    document.body.appendChild(outer);\n    var inner = document.createElement(\"div\");\n    outer.appendChild(inner);\n    var offsetType = type === \"width\" ? \"offsetWidth\" : \"offsetHeight\";\n    // the scrollbar width can be determined by comparing the width of the parent\n    // element that has scrollbars to the child element that does not.\n    value = outer[offsetType] - inner[offsetType];\n    cached[type] = value;\n    document.body.removeChild(outer);\n    return value;\n}\n//# sourceMappingURL=scrollbarSize.js.map"]},"metadata":{},"sourceType":"module"}