{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n};\n\nimport { useCallback, useReducer } from \"react\";\nimport { useRefCache } from \"@react-md/utils\";\nimport { createRippleState, getType, isBubbled, isRippleable } from \"./utils\";\nexport var CREATE = \"CREATE\";\nexport var CANCEL = \"CANCEL\";\nexport var RELEASE = \"RELEASE\";\nexport var ENTERED = \"ENTERED\";\nexport var REMOVE = \"REMOVE\";\n/**\n * This function will create a simplified version of the create event\n * that only includes the parts that are needed to trigger a ripple.\n * This is really only required since `event.persist()` crashed a lot\n * when spamming the trigger events and it threw warnings when not\n * persisting the event.\n */\n\nexport function createRippleAction(event, disableSpacebarClick) {\n  var _a = event,\n      type = _a.type,\n      target = _a.target,\n      currentTarget = _a.currentTarget,\n      touches = _a.touches,\n      pageX = _a.pageX,\n      pageY = _a.pageY,\n      button = _a.button,\n      key = _a.key;\n  return {\n    type: CREATE,\n    disableSpacebarClick: disableSpacebarClick,\n    event: {\n      type: type,\n      key: key,\n      target: target,\n      button: button,\n      currentTarget: currentTarget,\n      touches: touches,\n      pageX: pageX,\n      pageY: pageY\n    }\n  };\n}\n\nfunction createRipple(state, event, disableSpacebarClick) {\n  if (!isRippleable(event, disableSpacebarClick) || isBubbled(event)) {\n    return state;\n  }\n\n  if (state.find(function (r) {\n    return r.holding;\n  }) || getType(event) !== \"touch\" && state.find(function (r) {\n    return r.type === \"touch\";\n  })) {\n    // keyboard events are a bit different than the others since it is actually\n    // spammable since the space or enter key can be held down which triggers click\n    // events infinitely until they release. There's also the fun fact that mouse\n    // events are triggered after touch events, so we need to make sure duplicate\n    // ripples aren't created for these\n    return state;\n  }\n\n  var ripple = createRippleState(event);\n  return __spreadArray(__spreadArray([], state), [ripple]);\n}\n\nfunction enteredRipple(state, ripple) {\n  var i = state.findIndex(function (r) {\n    return r === ripple;\n  });\n\n  if (i === -1 || ripple.exiting) {\n    return state;\n  }\n\n  var nextState = state.slice();\n  var exiting = !ripple.holding || Date.now() - ripple.startTime > 300;\n  nextState[i] = __assign(__assign({}, ripple), {\n    exiting: exiting,\n    entered: true\n  });\n  return nextState;\n}\n\nfunction releaseRipple(state) {\n  var i = state.findIndex(function (r) {\n    return r.holding && !r.exiting;\n  });\n\n  if (i === -1) {\n    return state;\n  }\n\n  var ripple = state[i];\n  var exiting = ripple.entered || Date.now() - ripple.startTime > 300;\n  var nextState = state.slice();\n  nextState[i] = __assign(__assign({}, ripple), {\n    exiting: exiting,\n    holding: false\n  });\n  return nextState;\n}\n\nfunction removeRipple(state, ripple) {\n  var i = state.findIndex(function (r) {\n    return r.startTime === ripple.startTime;\n  });\n\n  if (i === -1) {\n    return state;\n  }\n\n  var nextState = state.slice();\n  nextState.splice(i, 1);\n  return nextState;\n}\n\nfunction cancelRipples(state, ease) {\n  if (ease) {\n    return state.map(function (r) {\n      return __assign(__assign({}, r), {\n        exiting: true,\n        mounted: true,\n        holding: false\n      });\n    });\n  }\n\n  return [];\n}\n\nexport function reducer(state, action) {\n  if (state === void 0) {\n    state = [];\n  }\n\n  switch (action.type) {\n    case CREATE:\n      return createRipple(state, action.event, action.disableSpacebarClick);\n\n    case RELEASE:\n      return releaseRipple(state);\n\n    case CANCEL:\n      return cancelRipples(state, action.ease);\n\n    case ENTERED:\n      return enteredRipple(state, action.ripple);\n\n    case REMOVE:\n      return removeRipple(state, action.ripple);\n\n    default:\n      return state;\n  }\n}\n/**\n * This hook creates memoized callbacks for each part of the ripple transition\n * as well as returning the current list of ripples.\n */\n\nexport function useRippleTransition(disableSpacebarClick) {\n  if (disableSpacebarClick === void 0) {\n    disableSpacebarClick = false;\n  }\n\n  var _a = useReducer(reducer, []),\n      state = _a[0],\n      dispatch = _a[1];\n\n  var spacebarRef = useRefCache(disableSpacebarClick);\n  var create = useCallback(function (event) {\n    var disableSpacebarClick = spacebarRef.current;\n    dispatch(createRippleAction(event, disableSpacebarClick)); // disabled since useRefCache\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n  var release = useCallback(function (event) {\n    dispatch({\n      type: RELEASE,\n      event: event\n    });\n  }, []);\n  var entered = useCallback(function (ripple) {\n    dispatch({\n      type: ENTERED,\n      ripple: ripple\n    });\n  }, []);\n  var cancel = useCallback(function (ease) {\n    if (ease === void 0) {\n      ease = false;\n    }\n\n    dispatch({\n      type: CANCEL,\n      ease: ease\n    });\n  }, []);\n  var remove = useCallback(function (ripple) {\n    dispatch({\n      type: REMOVE,\n      ripple: ripple\n    });\n  }, []);\n  return {\n    state: state,\n    create: create,\n    release: release,\n    entered: entered,\n    remove: remove,\n    cancel: cancel\n  };\n}","map":{"version":3,"sources":["../../src/ripples/reducer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from) {\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n        to[j] = from[i];\n    return to;\n};\nimport { useCallback, useReducer } from \"react\";\nimport { useRefCache } from \"@react-md/utils\";\nimport { createRippleState, getType, isBubbled, isRippleable } from \"./utils\";\nexport var CREATE = \"CREATE\";\nexport var CANCEL = \"CANCEL\";\nexport var RELEASE = \"RELEASE\";\nexport var ENTERED = \"ENTERED\";\nexport var REMOVE = \"REMOVE\";\n/**\n * This function will create a simplified version of the create event\n * that only includes the parts that are needed to trigger a ripple.\n * This is really only required since `event.persist()` crashed a lot\n * when spamming the trigger events and it threw warnings when not\n * persisting the event.\n */\nexport function createRippleAction(event, disableSpacebarClick) {\n    var _a = event, type = _a.type, target = _a.target, currentTarget = _a.currentTarget, touches = _a.touches, pageX = _a.pageX, pageY = _a.pageY, button = _a.button, key = _a.key;\n    return {\n        type: CREATE,\n        disableSpacebarClick: disableSpacebarClick,\n        event: {\n            type: type,\n            key: key,\n            target: target,\n            button: button,\n            currentTarget: currentTarget,\n            touches: touches,\n            pageX: pageX,\n            pageY: pageY,\n        },\n    };\n}\nfunction createRipple(state, event, disableSpacebarClick) {\n    if (!isRippleable(event, disableSpacebarClick) || isBubbled(event)) {\n        return state;\n    }\n    if (state.find(function (r) { return r.holding; }) ||\n        (getType(event) !== \"touch\" && state.find(function (r) { return r.type === \"touch\"; }))) {\n        // keyboard events are a bit different than the others since it is actually\n        // spammable since the space or enter key can be held down which triggers click\n        // events infinitely until they release. There's also the fun fact that mouse\n        // events are triggered after touch events, so we need to make sure duplicate\n        // ripples aren't created for these\n        return state;\n    }\n    var ripple = createRippleState(event);\n    return __spreadArray(__spreadArray([], state), [ripple]);\n}\nfunction enteredRipple(state, ripple) {\n    var i = state.findIndex(function (r) { return r === ripple; });\n    if (i === -1 || ripple.exiting) {\n        return state;\n    }\n    var nextState = state.slice();\n    var exiting = !ripple.holding || Date.now() - ripple.startTime > 300;\n    nextState[i] = __assign(__assign({}, ripple), { exiting: exiting, entered: true });\n    return nextState;\n}\nfunction releaseRipple(state) {\n    var i = state.findIndex(function (r) { return r.holding && !r.exiting; });\n    if (i === -1) {\n        return state;\n    }\n    var ripple = state[i];\n    var exiting = ripple.entered || Date.now() - ripple.startTime > 300;\n    var nextState = state.slice();\n    nextState[i] = __assign(__assign({}, ripple), { exiting: exiting, holding: false });\n    return nextState;\n}\nfunction removeRipple(state, ripple) {\n    var i = state.findIndex(function (r) { return r.startTime === ripple.startTime; });\n    if (i === -1) {\n        return state;\n    }\n    var nextState = state.slice();\n    nextState.splice(i, 1);\n    return nextState;\n}\nfunction cancelRipples(state, ease) {\n    if (ease) {\n        return state.map(function (r) { return (__assign(__assign({}, r), { exiting: true, mounted: true, holding: false })); });\n    }\n    return [];\n}\nexport function reducer(state, action) {\n    if (state === void 0) { state = []; }\n    switch (action.type) {\n        case CREATE:\n            return createRipple(state, action.event, action.disableSpacebarClick);\n        case RELEASE:\n            return releaseRipple(state);\n        case CANCEL:\n            return cancelRipples(state, action.ease);\n        case ENTERED:\n            return enteredRipple(state, action.ripple);\n        case REMOVE:\n            return removeRipple(state, action.ripple);\n        default:\n            return state;\n    }\n}\n/**\n * This hook creates memoized callbacks for each part of the ripple transition\n * as well as returning the current list of ripples.\n */\nexport function useRippleTransition(disableSpacebarClick) {\n    if (disableSpacebarClick === void 0) { disableSpacebarClick = false; }\n    var _a = useReducer(reducer, []), state = _a[0], dispatch = _a[1];\n    var spacebarRef = useRefCache(disableSpacebarClick);\n    var create = useCallback(function (event) {\n        var disableSpacebarClick = spacebarRef.current;\n        dispatch(createRippleAction(event, disableSpacebarClick));\n        // disabled since useRefCache\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    var release = useCallback(function (event) {\n        dispatch({ type: RELEASE, event: event });\n    }, []);\n    var entered = useCallback(function (ripple) {\n        dispatch({ type: ENTERED, ripple: ripple });\n    }, []);\n    var cancel = useCallback(function (ease) {\n        if (ease === void 0) { ease = false; }\n        dispatch({ type: CANCEL, ease: ease });\n    }, []);\n    var remove = useCallback(function (ripple) {\n        dispatch({ type: REMOVE, ripple: ripple });\n    }, []);\n    return { state: state, create: create, release: release, entered: entered, remove: remove, cancel: cancel };\n}\n//# sourceMappingURL=reducer.js.map"]},"metadata":{},"sourceType":"module"}