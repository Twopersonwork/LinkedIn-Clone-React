{"ast":null,"code":"import { getAboveCoord, getBelowCoord, getBottomCoord, getCenterYCoord, getTopCoord } from \"./getCoord\";\nimport { getViewportSize } from \"./getViewportSize\";\n/**\n * Attempts to position the fixed element so that it will appear completely\n * above the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the below position if it\n * can't fit within the viewport above the container element. If it can't fit in\n * the viewport even after being swapped below or swapping is disabled, it will\n * be positioned to the top viewport boundary.\n *\n * @internal\n */\n\nexport function createAnchoredAbove(config) {\n  var yMargin = config.yMargin,\n      vhMargin = config.vhMargin,\n      screenBottom = config.screenBottom,\n      elHeight = config.elHeight,\n      containerRect = config.containerRect,\n      preventOverlap = config.preventOverlap,\n      disableSwapping = config.disableSwapping,\n      disableVHBounds = config.disableVHBounds;\n  var top = getAboveCoord(config);\n  var actualY = \"above\";\n\n  if (disableVHBounds) {\n    // can't actually allow a top value as a negative number since browsers\n    // won't scroll upwards pas the normal page top\n    return {\n      actualY: actualY,\n      top: Math.max(0, top)\n    };\n  }\n\n  if (top > vhMargin) {\n    // don't need to do anything else since the top is still in the viewport and\n    // since it's positioned above, we already know it can't overlap the\n    // container element\n    return {\n      actualY: actualY,\n      top: top\n    };\n  }\n\n  var swappedTop = getBelowCoord(config);\n\n  if (disableSwapping || swappedTop + elHeight > screenBottom) {\n    top = vhMargin;\n  } else {\n    actualY = \"below\";\n    top = swappedTop;\n  }\n\n  var bottom;\n\n  if (preventOverlap && // can't overlap if it's positioned below\n  actualY === \"above\" && top + elHeight > containerRect.top) {\n    bottom = window.innerHeight - containerRect.top + yMargin;\n  }\n\n  return {\n    actualY: actualY,\n    top: top,\n    bottom: bottom\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear fixed to the\n * top of the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the bottom position if it\n * can't fit within the viewport. If it can't fit in the viewport even after\n * being swapped to the bottom position or swapping is disabled, it will be\n * positioned to the top viewport boundary.\n *\n * @internal\n */\n\nexport function createAnchoredTop(config) {\n  var vhMargin = config.vhMargin,\n      screenBottom = config.screenBottom,\n      elHeight = config.elHeight,\n      disableSwapping = config.disableSwapping,\n      disableVHBounds = config.disableVHBounds;\n  var top = getTopCoord(config);\n  var actualY = \"top\";\n\n  if (disableVHBounds || top + elHeight <= screenBottom) {\n    return {\n      actualY: actualY,\n      top: top\n    };\n  }\n\n  var swappedTop = getBottomCoord(config);\n\n  if (disableSwapping || swappedTop < vhMargin) {\n    top = vhMargin;\n  } else {\n    actualY = \"bottom\";\n    top = swappedTop;\n  }\n\n  return {\n    actualY: actualY,\n    top: top\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear at the center\n * of the container element but also within the viewport boundaries. If the\n * entered element can't fit within the viewport, it'll update the top value\n * to either be the vhMargin or position to the screen bottom boundary\n *\n * @internal\n */\n\nexport function createAnchoredCenter(config) {\n  var vhMargin = config.vhMargin,\n      screenBottom = config.screenBottom,\n      elHeight = config.elHeight,\n      disableVHBounds = config.disableVHBounds;\n  var top = getCenterYCoord(config);\n  var actualY = \"center\";\n\n  if (disableVHBounds) {\n    return {\n      actualY: actualY,\n      top: Math.max(0, top)\n    };\n  }\n\n  top = Math.max(vhMargin, top);\n\n  if (top + elHeight > screenBottom) {\n    top = screenBottom - elHeight;\n  }\n\n  return {\n    actualY: actualY,\n    top: top\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear fixed to the\n * bottom of the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the top position if it can't\n * fit within the viewport. If it can't fit in the viewport even after being\n * swapped to the top position or swapping is disabled, it will be positioned to\n * the bottom viewport boundary.\n *\n * @internal\n */\n\nexport function createAnchoredBottom(config) {\n  var vhMargin = config.vhMargin,\n      screenBottom = config.screenBottom,\n      elHeight = config.elHeight,\n      disableSwapping = config.disableSwapping,\n      disableVHBounds = config.disableVHBounds;\n  var top = getBottomCoord(config);\n  var actualY = \"bottom\";\n\n  if (disableVHBounds || top > vhMargin) {\n    return {\n      actualY: actualY,\n      top: top\n    };\n  }\n\n  var swappedTop = getTopCoord(config);\n\n  if (disableSwapping || swappedTop + elHeight > screenBottom) {\n    top = screenBottom - elHeight;\n  } else {\n    actualY = \"top\";\n    top = swappedTop;\n  }\n\n  return {\n    actualY: actualY,\n    top: top\n  };\n}\n/**\n * Attempts to position the fixed element so that it will appear completely\n * below the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the above position if it\n * can't fit within the viewport below the container element. If it can't fit in\n * the viewport even after being swapped above or swapping is disabled, it will\n * be positioned to the bottom viewport boundary.\n *\n * @internal\n */\n\nexport function createAnchoredBelow(config) {\n  var yMargin = config.yMargin,\n      vhMargin = config.vhMargin,\n      elHeight = config.elHeight,\n      screenBottom = config.screenBottom,\n      containerRect = config.containerRect,\n      preventOverlap = config.preventOverlap,\n      disableSwapping = config.disableSwapping,\n      disableVHBounds = config.disableVHBounds;\n  var top = getBelowCoord(config);\n  var actualY = \"below\";\n\n  if (disableVHBounds || top + elHeight <= screenBottom) {\n    return {\n      actualY: actualY,\n      top: top\n    };\n  }\n\n  if (preventOverlap) {\n    var availableTop = containerRect.top - yMargin;\n\n    if (disableSwapping || availableTop < screenBottom - top) {\n      return {\n        actualY: actualY,\n        top: top,\n        bottom: vhMargin\n      };\n    }\n\n    return {\n      actualY: \"above\",\n      top: Math.max(vhMargin, availableTop - elHeight),\n      // this makes it so that the bottom of the fixed element is the top of the container\n      // element. this ensures that it won't ever overlap the container element\n      bottom: getViewportSize(\"height\") - availableTop\n    };\n  }\n\n  var swappedTop = getAboveCoord(config);\n\n  if (disableSwapping || swappedTop < vhMargin) {\n    top = screenBottom - elHeight;\n  } else {\n    actualY = \"above\";\n    top = swappedTop;\n  }\n\n  return {\n    actualY: actualY,\n    top: top\n  };\n}\n/**\n * Creates the vertical position for a fixed element with the provided options.\n *\n * @internal\n */\n\nexport function createVerticalPosition(_a) {\n  var y = _a.y,\n      vh = _a.vh,\n      vhMargin = _a.vhMargin,\n      yMargin = _a.yMargin,\n      elHeight = _a.elHeight,\n      initialY = _a.initialY,\n      containerRect = _a.containerRect,\n      disableSwapping = _a.disableSwapping,\n      preventOverlap = _a.preventOverlap,\n      disableVHBounds = _a.disableVHBounds;\n\n  if (!disableVHBounds && !preventOverlap && elHeight > vh - vhMargin * 2) {\n    // the element is too big to be displayed in the viewport, so just span the\n    // full viewport excluding margins\n    return {\n      top: vhMargin,\n      bottom: vhMargin,\n      actualY: \"center\"\n    };\n  }\n\n  var config = {\n    vhMargin: vhMargin,\n    yMargin: yMargin,\n    elHeight: elHeight,\n    initialY: initialY,\n    containerRect: containerRect,\n    screenBottom: vh - vhMargin,\n    preventOverlap: preventOverlap,\n    disableSwapping: disableSwapping,\n    disableVHBounds: disableVHBounds\n  };\n\n  switch (y) {\n    case \"above\":\n      return createAnchoredAbove(config);\n\n    case \"top\":\n      return createAnchoredTop(config);\n\n    case \"center\":\n      return createAnchoredCenter(config);\n\n    case \"bottom\":\n      return createAnchoredBottom(config);\n\n    case \"below\":\n      return createAnchoredBelow(config);\n\n    default:\n      throw new Error(\"This should never happen\");\n  }\n}","map":{"version":3,"sources":["../../src/positioning/createVerticalPosition.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getAboveCoord, getBelowCoord, getBottomCoord, getCenterYCoord, getTopCoord, } from \"./getCoord\";\nimport { getViewportSize } from \"./getViewportSize\";\n/**\n * Attempts to position the fixed element so that it will appear completely\n * above the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the below position if it\n * can't fit within the viewport above the container element. If it can't fit in\n * the viewport even after being swapped below or swapping is disabled, it will\n * be positioned to the top viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredAbove(config) {\n    var yMargin = config.yMargin, vhMargin = config.vhMargin, screenBottom = config.screenBottom, elHeight = config.elHeight, containerRect = config.containerRect, preventOverlap = config.preventOverlap, disableSwapping = config.disableSwapping, disableVHBounds = config.disableVHBounds;\n    var top = getAboveCoord(config);\n    var actualY = \"above\";\n    if (disableVHBounds) {\n        // can't actually allow a top value as a negative number since browsers\n        // won't scroll upwards pas the normal page top\n        return { actualY: actualY, top: Math.max(0, top) };\n    }\n    if (top > vhMargin) {\n        // don't need to do anything else since the top is still in the viewport and\n        // since it's positioned above, we already know it can't overlap the\n        // container element\n        return { actualY: actualY, top: top };\n    }\n    var swappedTop = getBelowCoord(config);\n    if (disableSwapping || swappedTop + elHeight > screenBottom) {\n        top = vhMargin;\n    }\n    else {\n        actualY = \"below\";\n        top = swappedTop;\n    }\n    var bottom;\n    if (preventOverlap &&\n        // can't overlap if it's positioned below\n        actualY === \"above\" &&\n        top + elHeight > containerRect.top) {\n        bottom = window.innerHeight - containerRect.top + yMargin;\n    }\n    return { actualY: actualY, top: top, bottom: bottom };\n}\n/**\n * Attempts to position the fixed element so that it will appear fixed to the\n * top of the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the bottom position if it\n * can't fit within the viewport. If it can't fit in the viewport even after\n * being swapped to the bottom position or swapping is disabled, it will be\n * positioned to the top viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredTop(config) {\n    var vhMargin = config.vhMargin, screenBottom = config.screenBottom, elHeight = config.elHeight, disableSwapping = config.disableSwapping, disableVHBounds = config.disableVHBounds;\n    var top = getTopCoord(config);\n    var actualY = \"top\";\n    if (disableVHBounds || top + elHeight <= screenBottom) {\n        return { actualY: actualY, top: top };\n    }\n    var swappedTop = getBottomCoord(config);\n    if (disableSwapping || swappedTop < vhMargin) {\n        top = vhMargin;\n    }\n    else {\n        actualY = \"bottom\";\n        top = swappedTop;\n    }\n    return { actualY: actualY, top: top };\n}\n/**\n * Attempts to position the fixed element so that it will appear at the center\n * of the container element but also within the viewport boundaries. If the\n * entered element can't fit within the viewport, it'll update the top value\n * to either be the vhMargin or position to the screen bottom boundary\n *\n * @internal\n */\nexport function createAnchoredCenter(config) {\n    var vhMargin = config.vhMargin, screenBottom = config.screenBottom, elHeight = config.elHeight, disableVHBounds = config.disableVHBounds;\n    var top = getCenterYCoord(config);\n    var actualY = \"center\";\n    if (disableVHBounds) {\n        return { actualY: actualY, top: Math.max(0, top) };\n    }\n    top = Math.max(vhMargin, top);\n    if (top + elHeight > screenBottom) {\n        top = screenBottom - elHeight;\n    }\n    return { actualY: actualY, top: top };\n}\n/**\n * Attempts to position the fixed element so that it will appear fixed to the\n * bottom of the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the top position if it can't\n * fit within the viewport. If it can't fit in the viewport even after being\n * swapped to the top position or swapping is disabled, it will be positioned to\n * the bottom viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredBottom(config) {\n    var vhMargin = config.vhMargin, screenBottom = config.screenBottom, elHeight = config.elHeight, disableSwapping = config.disableSwapping, disableVHBounds = config.disableVHBounds;\n    var top = getBottomCoord(config);\n    var actualY = \"bottom\";\n    if (disableVHBounds || top > vhMargin) {\n        return { actualY: actualY, top: top };\n    }\n    var swappedTop = getTopCoord(config);\n    if (disableSwapping || swappedTop + elHeight > screenBottom) {\n        top = screenBottom - elHeight;\n    }\n    else {\n        actualY = \"top\";\n        top = swappedTop;\n    }\n    return { actualY: actualY, top: top };\n}\n/**\n * Attempts to position the fixed element so that it will appear completely\n * below the container element but also within the viewport boundaries. When\n * swapping is enabled, it will attempt to swap to the above position if it\n * can't fit within the viewport below the container element. If it can't fit in\n * the viewport even after being swapped above or swapping is disabled, it will\n * be positioned to the bottom viewport boundary.\n *\n * @internal\n */\nexport function createAnchoredBelow(config) {\n    var yMargin = config.yMargin, vhMargin = config.vhMargin, elHeight = config.elHeight, screenBottom = config.screenBottom, containerRect = config.containerRect, preventOverlap = config.preventOverlap, disableSwapping = config.disableSwapping, disableVHBounds = config.disableVHBounds;\n    var top = getBelowCoord(config);\n    var actualY = \"below\";\n    if (disableVHBounds || top + elHeight <= screenBottom) {\n        return { actualY: actualY, top: top };\n    }\n    if (preventOverlap) {\n        var availableTop = containerRect.top - yMargin;\n        if (disableSwapping || availableTop < screenBottom - top) {\n            return {\n                actualY: actualY,\n                top: top,\n                bottom: vhMargin,\n            };\n        }\n        return {\n            actualY: \"above\",\n            top: Math.max(vhMargin, availableTop - elHeight),\n            // this makes it so that the bottom of the fixed element is the top of the container\n            // element. this ensures that it won't ever overlap the container element\n            bottom: getViewportSize(\"height\") - availableTop,\n        };\n    }\n    var swappedTop = getAboveCoord(config);\n    if (disableSwapping || swappedTop < vhMargin) {\n        top = screenBottom - elHeight;\n    }\n    else {\n        actualY = \"above\";\n        top = swappedTop;\n    }\n    return { actualY: actualY, top: top };\n}\n/**\n * Creates the vertical position for a fixed element with the provided options.\n *\n * @internal\n */\nexport function createVerticalPosition(_a) {\n    var y = _a.y, vh = _a.vh, vhMargin = _a.vhMargin, yMargin = _a.yMargin, elHeight = _a.elHeight, initialY = _a.initialY, containerRect = _a.containerRect, disableSwapping = _a.disableSwapping, preventOverlap = _a.preventOverlap, disableVHBounds = _a.disableVHBounds;\n    if (!disableVHBounds && !preventOverlap && elHeight > vh - vhMargin * 2) {\n        // the element is too big to be displayed in the viewport, so just span the\n        // full viewport excluding margins\n        return {\n            top: vhMargin,\n            bottom: vhMargin,\n            actualY: \"center\",\n        };\n    }\n    var config = {\n        vhMargin: vhMargin,\n        yMargin: yMargin,\n        elHeight: elHeight,\n        initialY: initialY,\n        containerRect: containerRect,\n        screenBottom: vh - vhMargin,\n        preventOverlap: preventOverlap,\n        disableSwapping: disableSwapping,\n        disableVHBounds: disableVHBounds,\n    };\n    switch (y) {\n        case \"above\":\n            return createAnchoredAbove(config);\n        case \"top\":\n            return createAnchoredTop(config);\n        case \"center\":\n            return createAnchoredCenter(config);\n        case \"bottom\":\n            return createAnchoredBottom(config);\n        case \"below\":\n            return createAnchoredBelow(config);\n        default:\n            throw new Error(\"This should never happen\");\n    }\n}\n//# sourceMappingURL=createVerticalPosition.js.map"]},"metadata":{},"sourceType":"module"}