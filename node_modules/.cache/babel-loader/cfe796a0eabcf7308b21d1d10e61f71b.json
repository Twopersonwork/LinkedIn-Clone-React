{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport React, { Children, cloneElement, forwardRef, isValidElement } from \"react\";\nimport cn from \"classnames\";\nimport { bem } from \"../bem\";\nimport { useAppSize } from \"../sizing/useAppSize\";\nimport { GridCell } from \"./GridCell\";\n/**\n * This CSS Variable allows you to override the number of columns that should be\n * displayed in the grid. This is automatically updated with media queries with\n * the default grid implementation, but is used here to add additional\n * inline-style overrides.\n *\n * @internal\n */\n\nexport var GRID_COLUMNS_VAR = \"--rmd-grid-cols\";\n/**\n * This CSS Variable allows you to override the gutter (grid-gap) between each\n * cell in the grid.\n *\n * @internal\n */\n\nexport var GRID_GUTTER_VAR = \"--rmd-grid-gutter\";\nvar block = bem(\"rmd-grid\");\n/**\n * The grid component is generally used for a base layout in your app to provide\n * nice padding and spacing between each item.\n *\n * Note: This component relies on the `AppSizeListener` as a parent component to\n * work and will throw an error if it does not exist as a parent.\n */\n\nexport var Grid = forwardRef(function Grid(_a, ref) {\n  var _b;\n\n  var style = _a.style,\n      className = _a.className,\n      children = _a.children,\n      _c = _a.clone,\n      clone = _c === void 0 ? false : _c,\n      _d = _a.cloneStyles,\n      cloneStyles = _d === void 0 ? false : _d,\n      _e = _a.wrapOnly,\n      wrapOnly = _e === void 0 ? false : _e,\n      columns = _a.columns,\n      phoneColumns = _a.phoneColumns,\n      tabletColumns = _a.tabletColumns,\n      desktopColumns = _a.desktopColumns,\n      largeDesktopColumns = _a.largeDesktopColumns,\n      padding = _a.padding,\n      gutter = _a.gutter,\n      minCellWidth = _a.minCellWidth,\n      props = __rest(_a, [\"style\", \"className\", \"children\", \"clone\", \"cloneStyles\", \"wrapOnly\", \"columns\", \"phoneColumns\", \"tabletColumns\", \"desktopColumns\", \"largeDesktopColumns\", \"padding\", \"gutter\", \"minCellWidth\"]);\n\n  var _f = useAppSize(),\n      isPhone = _f.isPhone,\n      isTablet = _f.isTablet,\n      isDesktop = _f.isDesktop,\n      isLargeDesktop = _f.isLargeDesktop;\n\n  var mergedStyle = __assign(__assign({\n    padding: padding !== 0 && padding || undefined,\n    gridTemplateColumns: minCellWidth ? \"repeat(auto-fill, minmax(\" + minCellWidth + \", 1fr))\" : undefined\n  }, style), (_b = {}, _b[GRID_COLUMNS_VAR] = isPhone && phoneColumns || isTablet && tabletColumns || isLargeDesktop && largeDesktopColumns || isDesktop && desktopColumns || columns, _b[GRID_GUTTER_VAR] = gutter, _b));\n\n  var mergedClassName = cn(block({\n    \"no-padding\": padding === 0\n  }), className);\n\n  if (cloneStyles && isValidElement(children)) {\n    var child = Children.only(children);\n    return cloneElement(child, {\n      style: __assign(__assign({}, mergedStyle), child.props.style),\n      className: cn(mergedClassName, child.props.className)\n    });\n  }\n\n  var content = children;\n\n  if (clone || wrapOnly) {\n    content = Children.map(children, function (child) {\n      return child && React.createElement(GridCell, {\n        clone: clone\n      }, child);\n    });\n  }\n\n  return React.createElement(\"div\", __assign({}, props, {\n    ref: ref,\n    style: mergedStyle,\n    className: mergedClassName\n  }), content);\n});\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== \"production\") {\n  try {\n    var PropTypes = require(\"prop-types\");\n\n    Grid.propTypes = {\n      style: PropTypes.object,\n      className: PropTypes.string,\n      clone: PropTypes.bool,\n      cloneStyles: PropTypes.bool,\n      wrapOnly: PropTypes.bool,\n      columns: PropTypes.number,\n      phoneColumns: PropTypes.number,\n      tabletColumns: PropTypes.number,\n      desktopColumns: PropTypes.number,\n      largeDesktopColumns: PropTypes.number,\n      padding: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n      gutter: PropTypes.string,\n      children: PropTypes.node,\n      minCellWidth: PropTypes.string\n    };\n  } catch (e) {}\n}","map":{"version":3,"sources":["../../src/layout/Grid.tsx"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,KAAP,IACE,QADF,EAEE,YAFF,EAGE,UAHF,EAKE,cALF,QAMO,OANP;AAOA,OAAO,EAAP,MAAe,YAAf;AAEA,SAAS,GAAT,QAAoB,QAApB;AACA,SAAS,UAAT,QAA2B,sBAA3B;AACA,SAAS,QAAT,QAAyB,YAAzB;AAEA;;;;;;;AAOG;;AACH,OAAO,IAAM,gBAAgB,GAAG,iBAAzB;AAEP;;;;;AAKG;;AACH,OAAO,IAAM,eAAe,GAAG,mBAAxB;AAkGP,IAAM,KAAK,GAAG,GAAG,CAAC,UAAD,CAAjB;AAEA;;;;;;AAMG;;AACH,OAAO,IAAM,IAAI,GAAG,UAAU,CAA4B,SAAS,IAAT,CACxD,EADwD,EAkBxD,GAlBwD,EAkBrD;;;AAhBD,MAAA,KAAK,GAAA,EAAA,CAAA,KAAL;AAAA,MACA,SAAS,GAAA,EAAA,CAAA,SADT;AAAA,MAEA,QAAQ,GAAA,EAAA,CAAA,QAFR;AAAA,MAGA,EAAA,GAAA,EAAA,CAAA,KAHA;AAAA,MAGA,KAAK,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,EAHb;AAAA,MAIA,EAAA,GAAA,EAAA,CAAA,WAJA;AAAA,MAIA,WAAW,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,EAJnB;AAAA,MAKA,EAAA,GAAA,EAAA,CAAA,QALA;AAAA,MAKA,QAAQ,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,KAAH,GAAQ,EALhB;AAAA,MAMA,OAAO,GAAA,EAAA,CAAA,OANP;AAAA,MAOA,YAAY,GAAA,EAAA,CAAA,YAPZ;AAAA,MAQA,aAAa,GAAA,EAAA,CAAA,aARb;AAAA,MASA,cAAc,GAAA,EAAA,CAAA,cATd;AAAA,MAUA,mBAAmB,GAAA,EAAA,CAAA,mBAVnB;AAAA,MAWA,OAAO,GAAA,EAAA,CAAA,OAXP;AAAA,MAYA,MAAM,GAAA,EAAA,CAAA,MAZN;AAAA,MAaA,YAAY,GAAA,EAAA,CAAA,YAbZ;AAAA,MAcG,KAAK,GAAA,MAAA,CAAA,EAAA,EAfV,CAAA,OAAA,EAAA,WAAA,EAAA,UAAA,EAAA,OAAA,EAAA,aAAA,EAAA,UAAA,EAAA,SAAA,EAAA,cAAA,EAAA,eAAA,EAAA,gBAAA,EAAA,qBAAA,EAAA,SAAA,EAAA,QAAA,EAAA,cAAA,CAeU,CAdR;;AAkBI,MAAA,EAAA,GAAmD,UAAU,EAA7D;AAAA,MAAE,OAAO,GAAA,EAAA,CAAA,OAAT;AAAA,MAAW,QAAQ,GAAA,EAAA,CAAA,QAAnB;AAAA,MAAqB,SAAS,GAAA,EAAA,CAAA,SAA9B;AAAA,MAAgC,cAAc,GAAA,EAAA,CAAA,cAA9C;;AAEN,MAAM,WAAW,GAAA,QAAA,CAAA,QAAA,CAAA;AACf,IAAA,OAAO,EAAG,OAAO,KAAK,CAAZ,IAAiB,OAAlB,IAA8B,SADxB;AAEf,IAAA,mBAAmB,EAAE,YAAY,GAC7B,8BAA4B,YAA5B,GAAwC,SADX,GAE7B;AAJW,GAAA,EAKZ,KALY,CAAA,GAKP,EAAA,GAAA,EAAA,EAAA,EAAA,CACP,gBADO,CAAA,GAEL,OAAO,IAAI,YAAZ,IACC,QAAQ,IAAI,aADb,IAEC,cAAc,IAAI,mBAFnB,IAGC,SAAS,IAAI,cAHd,IAIA,OANM,EAMC,EAAA,CACR,eADQ,CAAA,GACU,MAPX,EAOiB,EAZV,EAAjB;;AAcA,MAAM,eAAe,GAAG,EAAE,CAAC,KAAK,CAAC;AAAE,kBAAc,OAAO,KAAK;AAA5B,GAAD,CAAN,EAAyC,SAAzC,CAA1B;;AAEA,MAAI,WAAW,IAAI,cAAc,CAAC,QAAD,CAAjC,EAA6C;AAC3C,QAAM,KAAK,GAAG,QAAQ,CAAC,IAAT,CAAc,QAAd,CAAd;AAEA,WAAO,YAAY,CAAC,KAAD,EAAQ;AACzB,MAAA,KAAK,EAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAO,WAAP,CAAA,EAAuB,KAAK,CAAC,KAAN,CAAY,KAAnC,CADoB;AAEzB,MAAA,SAAS,EAAE,EAAE,CAAC,eAAD,EAAkB,KAAK,CAAC,KAAN,CAAY,SAA9B;AAFY,KAAR,CAAnB;AAID;;AAED,MAAI,OAAO,GAAG,QAAd;;AACA,MAAI,KAAK,IAAI,QAAb,EAAuB;AACrB,IAAA,OAAO,GAAG,QAAQ,CAAC,GAAT,CACR,QADQ,EAER,UAAC,KAAD,EAAM;AAAK,aAAA,KAAK,IAAI,KAAA,CAAA,aAAA,CAAC,QAAD,EAAS;AAAC,QAAA,KAAK,EAAE;AAAR,OAAT,EAAT,KAAS,CAAT;AAAmD,KAFtD,CAAV;AAID;;AAED,SACE,KAAA,CAAA,aAAA,CAAA,KAAA,EAAA,QAAA,CAAA,EAAA,EAAS,KAAT,EAAc;AAAE,IAAA,GAAG,EAAE,GAAP;AAAY,IAAA,KAAK,EAAE,WAAnB;AAAgC,IAAA,SAAS,EAAE;AAA3C,GAAd,CAAA,EACG,OADH,CADF;AAKD,CA5D6B,CAAvB;AA8DP;;AACA,IAAI,OAAO,CAAC,GAAR,CAAY,QAAZ,KAAyB,YAA7B,EAA2C;AACzC,MAAI;AACF,QAAM,SAAS,GAAG,OAAO,CAAC,YAAD,CAAzB;;AAEA,IAAA,IAAI,CAAC,SAAL,GAAiB;AACf,MAAA,KAAK,EAAE,SAAS,CAAC,MADF;AAEf,MAAA,SAAS,EAAE,SAAS,CAAC,MAFN;AAGf,MAAA,KAAK,EAAE,SAAS,CAAC,IAHF;AAIf,MAAA,WAAW,EAAE,SAAS,CAAC,IAJR;AAKf,MAAA,QAAQ,EAAE,SAAS,CAAC,IALL;AAMf,MAAA,OAAO,EAAE,SAAS,CAAC,MANJ;AAOf,MAAA,YAAY,EAAE,SAAS,CAAC,MAPT;AAQf,MAAA,aAAa,EAAE,SAAS,CAAC,MARV;AASf,MAAA,cAAc,EAAE,SAAS,CAAC,MATX;AAUf,MAAA,mBAAmB,EAAE,SAAS,CAAC,MAVhB;AAWf,MAAA,OAAO,EAAE,SAAS,CAAC,SAAV,CAAoB,CAAC,SAAS,CAAC,MAAX,EAAmB,SAAS,CAAC,MAA7B,CAApB,CAXM;AAYf,MAAA,MAAM,EAAE,SAAS,CAAC,MAZH;AAaf,MAAA,QAAQ,EAAE,SAAS,CAAC,IAbL;AAcf,MAAA,YAAY,EAAE,SAAS,CAAC;AAdT,KAAjB;AAgBD,GAnBD,CAmBE,OAAO,CAAP,EAAU,CAAE;AACf","sourceRoot":"","sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport React, { Children, cloneElement, forwardRef, isValidElement, } from \"react\";\nimport cn from \"classnames\";\nimport { bem } from \"../bem\";\nimport { useAppSize } from \"../sizing/useAppSize\";\nimport { GridCell } from \"./GridCell\";\n/**\n * This CSS Variable allows you to override the number of columns that should be\n * displayed in the grid. This is automatically updated with media queries with\n * the default grid implementation, but is used here to add additional\n * inline-style overrides.\n *\n * @internal\n */\nexport var GRID_COLUMNS_VAR = \"--rmd-grid-cols\";\n/**\n * This CSS Variable allows you to override the gutter (grid-gap) between each\n * cell in the grid.\n *\n * @internal\n */\nexport var GRID_GUTTER_VAR = \"--rmd-grid-gutter\";\nvar block = bem(\"rmd-grid\");\n/**\n * The grid component is generally used for a base layout in your app to provide\n * nice padding and spacing between each item.\n *\n * Note: This component relies on the `AppSizeListener` as a parent component to\n * work and will throw an error if it does not exist as a parent.\n */\nexport var Grid = forwardRef(function Grid(_a, ref) {\n    var _b;\n    var style = _a.style, className = _a.className, children = _a.children, _c = _a.clone, clone = _c === void 0 ? false : _c, _d = _a.cloneStyles, cloneStyles = _d === void 0 ? false : _d, _e = _a.wrapOnly, wrapOnly = _e === void 0 ? false : _e, columns = _a.columns, phoneColumns = _a.phoneColumns, tabletColumns = _a.tabletColumns, desktopColumns = _a.desktopColumns, largeDesktopColumns = _a.largeDesktopColumns, padding = _a.padding, gutter = _a.gutter, minCellWidth = _a.minCellWidth, props = __rest(_a, [\"style\", \"className\", \"children\", \"clone\", \"cloneStyles\", \"wrapOnly\", \"columns\", \"phoneColumns\", \"tabletColumns\", \"desktopColumns\", \"largeDesktopColumns\", \"padding\", \"gutter\", \"minCellWidth\"]);\n    var _f = useAppSize(), isPhone = _f.isPhone, isTablet = _f.isTablet, isDesktop = _f.isDesktop, isLargeDesktop = _f.isLargeDesktop;\n    var mergedStyle = __assign(__assign({ padding: (padding !== 0 && padding) || undefined, gridTemplateColumns: minCellWidth\n            ? \"repeat(auto-fill, minmax(\" + minCellWidth + \", 1fr))\"\n            : undefined }, style), (_b = {}, _b[GRID_COLUMNS_VAR] = (isPhone && phoneColumns) ||\n        (isTablet && tabletColumns) ||\n        (isLargeDesktop && largeDesktopColumns) ||\n        (isDesktop && desktopColumns) ||\n        columns, _b[GRID_GUTTER_VAR] = gutter, _b));\n    var mergedClassName = cn(block({ \"no-padding\": padding === 0 }), className);\n    if (cloneStyles && isValidElement(children)) {\n        var child = Children.only(children);\n        return cloneElement(child, {\n            style: __assign(__assign({}, mergedStyle), child.props.style),\n            className: cn(mergedClassName, child.props.className),\n        });\n    }\n    var content = children;\n    if (clone || wrapOnly) {\n        content = Children.map(children, function (child) { return child && React.createElement(GridCell, { clone: clone }, child); });\n    }\n    return (React.createElement(\"div\", __assign({}, props, { ref: ref, style: mergedStyle, className: mergedClassName }), content));\n});\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== \"production\") {\n    try {\n        var PropTypes = require(\"prop-types\");\n        Grid.propTypes = {\n            style: PropTypes.object,\n            className: PropTypes.string,\n            clone: PropTypes.bool,\n            cloneStyles: PropTypes.bool,\n            wrapOnly: PropTypes.bool,\n            columns: PropTypes.number,\n            phoneColumns: PropTypes.number,\n            tabletColumns: PropTypes.number,\n            desktopColumns: PropTypes.number,\n            largeDesktopColumns: PropTypes.number,\n            padding: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),\n            gutter: PropTypes.string,\n            children: PropTypes.node,\n            minCellWidth: PropTypes.string,\n        };\n    }\n    catch (e) { }\n}\n//# sourceMappingURL=Grid.js.map"]},"metadata":{},"sourceType":"module"}